const JsError = Error;
export var Op;
(function (Op) {
    Op.loading = () => ({ status: "loading" });
    Op.error = (reason) => ({ status: "error", reason });
    Op.ready = (payload) => ({ status: "ready", payload });
    Op.is = Object.freeze({
        loading: (op) => op.status === "loading",
        error: (op) => op.status === "error",
        ready: (op) => op.status === "ready",
    });
    function payload(op) {
        return (op.status === "ready")
            ? op.payload
            : undefined;
    }
    Op.payload = payload;
    function reason(op) {
        return (op.status === "error")
            ? op.reason
            : undefined;
    }
    Op.reason = reason;
    function select(op, choices) {
        switch (op.status) {
            case "loading":
                return choices.loading();
            case "error":
                return choices.error(op.reason);
            case "ready":
                return choices.ready(op.payload);
            default:
                console.error("op", op);
                throw new JsError("invalid op status");
        }
    }
    Op.select = select;
    async function load(set_op, operation) {
        set_op(Op.loading());
        try {
            const payload = await operation();
            set_op(Op.ready(payload));
            return payload;
        }
        catch (err) {
            const reason = (err instanceof JsError)
                ? err.message
                : (typeof err === "string")
                    ? err
                    : "error";
            set_op(Op.error(reason));
            throw err;
        }
    }
    Op.load = load;
    function morph(op, transmute) {
        return select(op, {
            loading: () => Op.loading(),
            error: reason => Op.error(reason),
            ready: a => Op.ready(transmute(a)),
        });
    }
    Op.morph = morph;
})(Op || (Op = {}));
//# sourceMappingURL=op.js.map