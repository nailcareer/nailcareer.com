var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
export function mixinSetups(Base) {
    var _setups, _setdowns, _a;
    return _a = class extends Base {
            constructor() {
                super(...arguments);
                _setups.set(this, new Set()
                    .add(() => this.setup()));
                _setdowns.set(this, new Set());
            }
            register_setup(setup) {
                __classPrivateFieldGet(this, _setups, "f").add(setup);
            }
            setup() {
                return () => { };
            }
            connectedCallback() {
                for (const setup of __classPrivateFieldGet(this, _setups, "f"))
                    __classPrivateFieldGet(this, _setdowns, "f").add(setup());
            }
            disconnectedCallback() {
                for (const setdown of __classPrivateFieldGet(this, _setdowns, "f"))
                    setdown();
                __classPrivateFieldGet(this, _setdowns, "f").clear();
            }
        },
        _setups = new WeakMap(),
        _setdowns = new WeakMap(),
        _a;
}
//# sourceMappingURL=mixin_setups.js.map