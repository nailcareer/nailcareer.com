export function parse_prefixes(...partstrings) {
    const prefixes = new Set();
    const parts = partstrings
        .map(part => part !== null && part !== void 0 ? part : "")
        .flatMap(parse_part);
    for (const part of parts)
        prefixes.add(part);
    return prefixes;
}
export function query_attributes(container, attributes) {
    return Object.fromEntries(Object.entries(attributes).map(([key, attr]) => [
        key,
        Array.from(container.querySelectorAll(`[${attr}]`))
            .map(e => e.getAttribute(attr)),
    ]));
}
export function parse_part(attr) {
    return attr
        .split(/\s+/)
        .map(s => s.trim())
        .filter(s => !!s);
}
export function parse_exportparts(attr) {
    return attr
        .split(",")
        .map(s => s.trim())
        .filter(s => !!s)
        .map(s => s.includes(":")
        ? s.split(":").map(s => s.trim())[1]
        : s);
}
export function stitch_exportparts_together(parts, gparts) {
    return ((prefix) => [...parts].flatMap(part => [
        `${part}:${prefix}-${part}`,
        ...(gparts.has(part) ? [part] : []),
    ]));
}
//# sourceMappingURL=utils.js.map