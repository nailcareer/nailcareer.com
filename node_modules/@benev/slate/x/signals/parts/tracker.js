var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SignalTracker_instances, _SignalTracker_active, _SignalTracker_all_signals, _SignalTracker_waiters, _SignalTracker_relevant_signals, _SignalTracker_stoppers, _SignalTracker_actuate, _SignalTracker_reset_all_signals_accessed_indicator, _SignalTracker_signals_that_should_be_tracked_get;
import { accessed } from "./accessed_symbol.js";
import { debounce } from "../../tools/debounce/debounce.js";
export class SignalTracker {
    constructor({ all_signals, waiters, }) {
        _SignalTracker_instances.add(this);
        _SignalTracker_active.set(this, true);
        _SignalTracker_all_signals.set(this, void 0);
        _SignalTracker_waiters.set(this, void 0);
        _SignalTracker_relevant_signals.set(this, new Set());
        _SignalTracker_stoppers.set(this, new Set());
        _SignalTracker_actuate.set(this, debounce(0, (track) => {
            if (__classPrivateFieldGet(this, _SignalTracker_active, "f")) {
                if ("lean" in track)
                    track.actor();
                else {
                    const { payload, recording } = this.observe(track.collector);
                    this.add_listeners(track, recording);
                    if (track.responder)
                        track.responder(payload);
                }
            }
        }));
        __classPrivateFieldSet(this, _SignalTracker_all_signals, all_signals, "f");
        __classPrivateFieldSet(this, _SignalTracker_waiters, waiters, "f");
    }
    observe(collector) {
        __classPrivateFieldGet(this, _SignalTracker_instances, "m", _SignalTracker_reset_all_signals_accessed_indicator).call(this);
        const payload = collector();
        return {
            payload,
            recording: __classPrivateFieldGet(this, _SignalTracker_instances, "a", _SignalTracker_signals_that_should_be_tracked_get),
        };
    }
    add_listeners(track, recording) {
        for (const signal of recording) {
            __classPrivateFieldGet(this, _SignalTracker_relevant_signals, "f").add(signal);
            __classPrivateFieldGet(this, _SignalTracker_stoppers, "f").add(signal.subscribe(() => __classPrivateFieldGet(this, _SignalTracker_waiters, "f").add(__classPrivateFieldGet(this, _SignalTracker_actuate, "f").call(this, track))));
        }
    }
    shutdown() {
        __classPrivateFieldSet(this, _SignalTracker_active, false, "f");
        __classPrivateFieldGet(this, _SignalTracker_stoppers, "f").forEach(stop => stop());
    }
}
_SignalTracker_active = new WeakMap(), _SignalTracker_all_signals = new WeakMap(), _SignalTracker_waiters = new WeakMap(), _SignalTracker_relevant_signals = new WeakMap(), _SignalTracker_stoppers = new WeakMap(), _SignalTracker_actuate = new WeakMap(), _SignalTracker_instances = new WeakSet(), _SignalTracker_reset_all_signals_accessed_indicator = function _SignalTracker_reset_all_signals_accessed_indicator() {
    for (const signal of __classPrivateFieldGet(this, _SignalTracker_all_signals, "f"))
        signal[accessed] = false;
}, _SignalTracker_signals_that_should_be_tracked_get = function _SignalTracker_signals_that_should_be_tracked_get() {
    return [...__classPrivateFieldGet(this, _SignalTracker_all_signals, "f")].filter(signal => (signal[accessed] &&
        !__classPrivateFieldGet(this, _SignalTracker_relevant_signals, "f").has(signal)));
};
//# sourceMappingURL=tracker.js.map