import { save_reaction } from "./save_reaction.js";
import { CircularFlatstateError } from "./errors.js";
export function proxy_handlers(tracker, recorder, locker, stopper, scheduler) {
    function actuate([symbol, reaction]) {
        if ("lean" in reaction) {
            reaction.actor();
        }
        else {
            const { payload, recording } = recorder.record(reaction.collector);
            stopper.add(symbol, save_reaction(symbol, recording, tracker, reaction));
            if (reaction.responder)
                reaction.responder(payload);
        }
    }
    return {
        get: (state, key) => {
            recorder.record_that_key_was_accessed(state, key);
            return state[key];
        },
        set: (state, key, value) => {
            if (locker.locked)
                throw new CircularFlatstateError(key);
            state[key] = value;
            const reactions = [...tracker.grab_keymap(state).grab_symbolmap(key)];
            for (const entry of reactions) {
                const [symbol] = entry;
                scheduler.add(symbol, () => locker.lock(() => actuate(entry)));
            }
            return true;
        },
    };
}
//# sourceMappingURL=proxy_handlers.js.map