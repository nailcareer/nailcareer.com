export function* compile(expressions) {
    function recurse(expression, previousSelector) {
        let css = [];
        const selector = expression[0];
        // This is an at-rule, not a regular selector.
        if (selector.startsWith("@")) {
            const directive = expression[0];
            const children = expression[1];
            css.push(`${stripAwayComments(directive)}`);
            for (const child of children)
                css = [...css, ...recurse(child, undefined)];
            css.push(`}`);
        }
        // This is a regular selector.
        else {
            const rules = expression[1];
            const children = expression[2];
            const compoundSelector = previousSelector
                ? handleParentReference(`${previousSelector} ${selector}`)
                : selector;
            const ruleEntries = Object.entries(rules);
            if (ruleEntries.length > 0) {
                const rulesString = ruleEntries
                    .map(([ruleName, ruleValue]) => `\t${ruleName}: ${stripAwayComments(ruleValue)};`)
                    .join("\n");
                css.push(`${stripAwayComments(compoundSelector)} {\n${rulesString}\n}`);
            }
            for (const child of children)
                css = [...css, ...recurse(child, compoundSelector)];
        }
        return css;
    }
    yield "\n";
    for (const expression of expressions)
        yield "\n" + recurse(expression, undefined).join("\n");
    yield "\n";
}
function stripAwayComments(text) {
    return text.replaceAll(/(\s*)(\/\/.*)$/gm, "");
}
function handleParentReference(groupedSelector) {
    return groupedSelector.replaceAll(/(\s+)*(\^|&)/gm, "");
}
//# sourceMappingURL=compile.js.map