
	Array.prototype.at = function(index) {
		return index >= 0
			? this[index]
			: this[this.length + index]
	}
var __classPrivateFieldSet$r = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$y = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Locker_locked;
class Locker {
    constructor() {
        _Locker_locked.set(this, false);
    }
    lock(fn) {
        __classPrivateFieldSet$r(this, _Locker_locked, true, "f");
        const result = fn();
        __classPrivateFieldSet$r(this, _Locker_locked, false, "f");
        return result;
    }
    get locked() {
        return __classPrivateFieldGet$y(this, _Locker_locked, "f");
    }
}
_Locker_locked = new WeakMap();

const make_map = () => new Map();
const make_set = () => new Set();

function maptool(map) {
    return new MapTool(map);
}
class MapTool {
    constructor(map) {
        this.map = map;
    }
    grab(key, make) {
        const { map } = this;
        if (map.has(key))
            return map.get(key);
        else {
            const value = make();
            map.set(key, value);
            return value;
        }
    }
}

var __classPrivateFieldGet$x = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$q = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Tracker_tracking;
class Tracker {
    constructor() {
        _Tracker_tracking.set(this, new WeakMap());
    }
    grab_keymap(state) {
        const keymap = maptool(__classPrivateFieldGet$x(this, _Tracker_tracking, "f")).grab(state, make_map);
        return {
            keymap,
            grab_symbolmap(key) {
                return maptool(keymap).grab(key, make_map);
            },
        };
    }
    clear() {
        __classPrivateFieldSet$q(this, _Tracker_tracking, new WeakMap(), "f");
    }
}
_Tracker_tracking = new WeakMap();

var __classPrivateFieldGet$w = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Stopper_map;
class Stopper {
    constructor() {
        _Stopper_map.set(this, new Map);
    }
    stop(symbol) {
        const stop = __classPrivateFieldGet$w(this, _Stopper_map, "f").get(symbol);
        if (stop) {
            __classPrivateFieldGet$w(this, _Stopper_map, "f").delete(symbol);
            stop();
        }
    }
    add(symbol, fun) {
        __classPrivateFieldGet$w(this, _Stopper_map, "f").set(symbol, fun);
    }
}
_Stopper_map = new WeakMap();

var __classPrivateFieldGet$v = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Recorder_recordings;
class Recorder {
    constructor() {
        _Recorder_recordings.set(this, []);
    }
    record(fn) {
        const recording = make_map();
        __classPrivateFieldGet$v(this, _Recorder_recordings, "f").push(recording);
        const payload = fn();
        __classPrivateFieldGet$v(this, _Recorder_recordings, "f").pop();
        return { payload, recording };
    }
    record_that_key_was_accessed(state, key) {
        const recording = __classPrivateFieldGet$v(this, _Recorder_recordings, "f").at(-1);
        if (recording) {
            const keyset = maptool(recording).grab(state, make_set);
            keyset.add(key);
        }
    }
}
_Recorder_recordings = new WeakMap();

class FlatstateError extends Error {
    constructor() {
        super(...arguments);
        this.name = this.constructor.name;
    }
}
class CircularFlatstateError extends FlatstateError {
    constructor(key) {
        super(`forbidden circularity, rejected assignment to "${key}"`);
    }
}
class ReadonlyError extends FlatstateError {
    constructor(key) {
        super(`forbidden assignment to readonly property "${key}"`);
    }
}

function readonly(s) {
    return new Proxy(s, {
        get(target, key) {
            return target[key];
        },
        set(_, key) {
            throw new ReadonlyError(key);
        },
    });
}

function debounce(delay, action) {
    let latestArgs;
    let timeout;
    let waitingQueue = [];
    function reset() {
        latestArgs = [];
        if (timeout)
            clearTimeout(timeout);
        timeout = undefined;
        waitingQueue = [];
    }
    reset();
    return ((...args) => {
        latestArgs = args;
        if (timeout)
            clearTimeout(timeout);
        const promise = new Promise((resolve, reject) => {
            waitingQueue.push({ resolve, reject });
        });
        timeout = setTimeout(() => {
            Promise.resolve()
                .then(() => action(...latestArgs))
                .then(r => {
                for (const { resolve } of waitingQueue)
                    resolve(r);
                reset();
            })
                .catch(err => {
                for (const { reject } of waitingQueue)
                    reject(err);
                reset();
            });
        }, delay);
        return promise;
    });
}

var __classPrivateFieldGet$u = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$p = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Scheduler_queue, _Scheduler_wait, _Scheduler_actuate;
class Scheduler {
    constructor() {
        _Scheduler_queue.set(this, new Map());
        _Scheduler_wait.set(this, Promise.resolve());
        _Scheduler_actuate.set(this, debounce(0, () => {
            const functions = [...__classPrivateFieldGet$u(this, _Scheduler_queue, "f").values()];
            __classPrivateFieldGet$u(this, _Scheduler_queue, "f").clear();
            for (const fun of functions)
                fun();
        }));
    }
    get wait() {
        return __classPrivateFieldGet$u(this, _Scheduler_wait, "f");
    }
    add(symbol, fun) {
        __classPrivateFieldGet$u(this, _Scheduler_queue, "f").set(symbol, fun);
        __classPrivateFieldSet$p(this, _Scheduler_wait, __classPrivateFieldGet$u(this, _Scheduler_actuate, "f").call(this), "f");
    }
}
_Scheduler_queue = new WeakMap(), _Scheduler_wait = new WeakMap(), _Scheduler_actuate = new WeakMap();

function collectivize(state) {
    return function (collector) {
        return () => {
            const s = typeof state === "function"
                ? state()
                : state;
            return collector(s);
        };
    };
}

function save_reaction(symbol, recording, tracker, reaction) {
    const stoppers = [];
    for (const [state, keyset] of recording) {
        const { grab_symbolmap } = tracker.grab_keymap(state);
        for (const key of keyset) {
            const symbolmap = grab_symbolmap(key);
            symbolmap.set(symbol, reaction);
            stoppers.push(() => symbolmap.delete(symbol));
        }
    }
    return () => stoppers.forEach(stop => stop());
}

function proxy_handlers(tracker, recorder, locker, stopper, scheduler) {
    function actuate([symbol, reaction]) {
        if ("lean" in reaction) {
            reaction.actor();
        }
        else {
            const { payload, recording } = recorder.record(reaction.collector);
            stopper.add(symbol, save_reaction(symbol, recording, tracker, reaction));
            if (reaction.responder)
                reaction.responder(payload);
        }
    }
    return {
        get: (state, key) => {
            recorder.record_that_key_was_accessed(state, key);
            return state[key];
        },
        set: (state, key, value) => {
            if (locker.locked)
                throw new CircularFlatstateError(key);
            state[key] = value;
            const reactions = [...tracker.grab_keymap(state).grab_symbolmap(key)];
            for (const entry of reactions) {
                const [symbol] = entry;
                scheduler.add(symbol, () => locker.lock(() => actuate(entry)));
            }
            return true;
        },
    };
}

var __classPrivateFieldGet$t = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Flat_tracker, _Flat_recorder, _Flat_locker, _Flat_stopper, _Flat_scheduler, _Flat_proxy_handlers;
class Flat {
    constructor() {
        _Flat_tracker.set(this, new Tracker());
        _Flat_recorder.set(this, new Recorder());
        _Flat_locker.set(this, new Locker());
        _Flat_stopper.set(this, new Stopper());
        _Flat_scheduler.set(this, new Scheduler());
        _Flat_proxy_handlers.set(this, proxy_handlers(__classPrivateFieldGet$t(this, _Flat_tracker, "f"), __classPrivateFieldGet$t(this, _Flat_recorder, "f"), __classPrivateFieldGet$t(this, _Flat_locker, "f"), __classPrivateFieldGet$t(this, _Flat_stopper, "f"), __classPrivateFieldGet$t(this, _Flat_scheduler, "f")));
    }
    get wait() {
        return __classPrivateFieldGet$t(this, _Flat_scheduler, "f").wait;
    }
    state(state) {
        return new Proxy(state, __classPrivateFieldGet$t(this, _Flat_proxy_handlers, "f"));
    }
    reaction(collector, responder) {
        const symbol = Symbol();
        const { recording } = __classPrivateFieldGet$t(this, _Flat_recorder, "f").record(() => __classPrivateFieldGet$t(this, _Flat_locker, "f").lock(collector));
        __classPrivateFieldGet$t(this, _Flat_stopper, "f").add(symbol, save_reaction(symbol, recording, __classPrivateFieldGet$t(this, _Flat_tracker, "f"), { collector, responder }));
        return () => __classPrivateFieldGet$t(this, _Flat_stopper, "f").stop(symbol);
    }
    lean(actor) {
        const symbol = Symbol();
        return {
            stop: () => __classPrivateFieldGet$t(this, _Flat_stopper, "f").stop(symbol),
            collect: collector => {
                const { payload, recording } = __classPrivateFieldGet$t(this, _Flat_recorder, "f").record(() => __classPrivateFieldGet$t(this, _Flat_locker, "f").lock(collector));
                __classPrivateFieldGet$t(this, _Flat_stopper, "f").add(symbol, save_reaction(symbol, recording, __classPrivateFieldGet$t(this, _Flat_tracker, "f"), { lean: true, actor }));
                return payload;
            },
        };
    }
    clear() {
        __classPrivateFieldGet$t(this, _Flat_tracker, "f").clear();
    }
}
_Flat_tracker = new WeakMap(), _Flat_recorder = new WeakMap(), _Flat_locker = new WeakMap(), _Flat_stopper = new WeakMap(), _Flat_scheduler = new WeakMap(), _Flat_proxy_handlers = new WeakMap();
Flat.readonly = readonly;
Flat.collectivize = collectivize;

const JsError = Error;
var Op;
(function (Op) {
    Op.loading = () => ({ mode: "loading" });
    Op.error = (reason) => ({ mode: "error", reason });
    Op.ready = (payload) => ({ mode: "ready", payload });
    Op.is = Object.freeze({
        loading: (op) => op.mode === "loading",
        error: (op) => op.mode === "error",
        ready: (op) => op.mode === "ready",
    });
    function payload(op) {
        return (op.mode === "ready")
            ? op.payload
            : undefined;
    }
    Op.payload = payload;
    function select(op, choices) {
        switch (op.mode) {
            case "loading":
                return choices.loading();
            case "error":
                return choices.error(op.reason);
            case "ready":
                return choices.ready(op.payload);
            default:
                console.error("op", op);
                throw new JsError("invalid op mode");
        }
    }
    Op.select = select;
    async function run(set_op, operation) {
        set_op(Op.loading());
        try {
            const payload = await operation();
            set_op(Op.ready(payload));
            return payload;
        }
        catch (err) {
            const reason = (err instanceof JsError)
                ? err.message
                : (typeof err === "string")
                    ? err
                    : "error";
            set_op(Op.error(reason));
        }
    }
    Op.run = run;
    function morph(op, transmute) {
        return select(op, {
            loading: () => Op.loading(),
            error: reason => Op.error(reason),
            ready: a => Op.ready(transmute(a)),
        });
    }
    Op.morph = morph;
})(Op || (Op = {}));

function prep_render_op({ loading, error }) {
    return function render_op(op, on_ready) {
        return Op.select(op, {
            loading,
            error,
            ready: on_ready,
        });
    };
}

var __classPrivateFieldGet$s = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Reactor_wait;
class Reactor {
    constructor(flat, signals) {
        this.flat = flat;
        this.signals = signals;
        _Reactor_wait.set(this, Promise.resolve());
    }
    get wait() {
        return Promise
            .all([this.flat.wait, this.signals.wait])
            .then(() => __classPrivateFieldGet$s(this, _Reactor_wait, "f"));
    }
    reaction(collector, responder) {
        const actuate = responder
            ? () => responder(collect())
            : () => collect();
        const lean = this.lean(actuate);
        const collect = () => lean.collect(collector);
        collect();
        return lean.stop;
    }
    lean(actor) {
        const lean1 = this.flat.lean(actor);
        const lean2 = this.signals.lean(actor);
        return {
            stop() {
                lean1.stop();
                lean2.stop();
            },
            collect(collector) {
                return lean1.collect(() => lean2.collect(collector));
            },
        };
    }
}
_Reactor_wait = new WeakMap();

var __classPrivateFieldSet$o = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$r = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Slice_options;
class Slice {
    constructor(options) {
        _Slice_options.set(this, void 0);
        __classPrivateFieldSet$o(this, _Slice_options, options, "f");
    }
    get state() {
        return __classPrivateFieldGet$r(this, _Slice_options, "f").getter(__classPrivateFieldGet$r(this, _Slice_options, "f").parent.state);
    }
    transmute(fun) {
        __classPrivateFieldGet$r(this, _Slice_options, "f").parent.transmute(state => {
            const x1 = __classPrivateFieldGet$r(this, _Slice_options, "f").getter(state);
            const x2 = fun(x1);
            const new_state = __classPrivateFieldGet$r(this, _Slice_options, "f").setter(state, x2);
            return new_state;
        });
    }
    slice({ getter, setter }) {
        return new Slice({
            parent: this,
            getter,
            setter,
        });
    }
}
_Slice_options = new WeakMap();

function deepFreeze(obj) {
    if (obj === null || typeof obj !== 'object')
        return obj;
    Object.values(obj).forEach(value => {
        if (typeof value === 'object' && value !== null)
            deepFreeze(value);
    });
    return Object.freeze(obj);
}

var __classPrivateFieldGet$q = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$n = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _StateTree_instances, _StateTree_state, _StateTree_readable, _StateTree_onChange, _StateTree_circularity_lock, _StateTree_make_frozen_clone;
class StateTree {
    constructor(state, onChange = () => { }) {
        _StateTree_instances.add(this);
        _StateTree_state.set(this, void 0);
        _StateTree_readable.set(this, void 0);
        _StateTree_onChange.set(this, void 0);
        _StateTree_circularity_lock.set(this, false);
        __classPrivateFieldSet$n(this, _StateTree_state, structuredClone(state), "f");
        __classPrivateFieldSet$n(this, _StateTree_readable, __classPrivateFieldGet$q(this, _StateTree_instances, "m", _StateTree_make_frozen_clone).call(this), "f");
        __classPrivateFieldSet$n(this, _StateTree_onChange, onChange, "f");
    }
    get state() {
        return __classPrivateFieldGet$q(this, _StateTree_readable, "f");
    }
    transmute(fun) {
        if (__classPrivateFieldGet$q(this, _StateTree_circularity_lock, "f"))
            throw new Error("circular error");
        __classPrivateFieldSet$n(this, _StateTree_circularity_lock, true, "f");
        __classPrivateFieldSet$n(this, _StateTree_state, fun(structuredClone(__classPrivateFieldGet$q(this, _StateTree_state, "f"))), "f");
        __classPrivateFieldSet$n(this, _StateTree_readable, __classPrivateFieldGet$q(this, _StateTree_instances, "m", _StateTree_make_frozen_clone).call(this), "f");
        __classPrivateFieldGet$q(this, _StateTree_onChange, "f").call(this);
        __classPrivateFieldSet$n(this, _StateTree_circularity_lock, false, "f");
    }
    slice({ getter, setter }) {
        return new Slice({
            parent: this,
            getter,
            setter,
        });
    }
}
_StateTree_state = new WeakMap(), _StateTree_readable = new WeakMap(), _StateTree_onChange = new WeakMap(), _StateTree_circularity_lock = new WeakMap(), _StateTree_instances = new WeakSet(), _StateTree_make_frozen_clone = function _StateTree_make_frozen_clone() {
    return deepFreeze(structuredClone(__classPrivateFieldGet$q(this, _StateTree_state, "f")));
};

const deepEqual = (alpha, bravo) => {
    if (alpha === bravo)
        return true;
    if (typeof alpha !== 'object' || alpha === null || typeof bravo !== 'object' || bravo === null)
        return false;
    const keys1 = Object.keys(alpha);
    const keys2 = Object.keys(bravo);
    if (keys1.length !== keys2.length)
        return false;
    for (const key of keys1) {
        if (!keys2.includes(key))
            return false;
        if (!deepEqual(alpha[key], bravo[key]))
            return false;
    }
    return true;
};

var __classPrivateFieldSet$m = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$p = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _WatchTower_signals, _WatchTower_computeds, _WatchTower_listeners, _WatchTower_memory;
class WatchTower {
    constructor(signals) {
        _WatchTower_signals.set(this, void 0);
        _WatchTower_computeds.set(this, new Set());
        _WatchTower_listeners.set(this, new Set());
        _WatchTower_memory.set(this, new Map());
        __classPrivateFieldSet$m(this, _WatchTower_signals, signals, "f");
    }
    dispatch() {
        for (const computed of __classPrivateFieldGet$p(this, _WatchTower_computeds, "f"))
            computed();
        for (const listener of __classPrivateFieldGet$p(this, _WatchTower_listeners, "f"))
            listener();
    }
    computed(fun) {
        const box = __classPrivateFieldGet$p(this, _WatchTower_signals, "f").signal(fun());
        __classPrivateFieldGet$p(this, _WatchTower_computeds, "f").add(() => { box.value = fun(); });
        return box;
    }
    track(collector, responder) {
        let first = true;
        const listener = () => {
            const current = collector();
            const previous = __classPrivateFieldGet$p(this, _WatchTower_memory, "f").get(collector);
            if (first || !deepEqual(current, previous)) {
                first = false;
                __classPrivateFieldGet$p(this, _WatchTower_memory, "f").set(collector, current);
                responder(current);
            }
        };
        listener();
        __classPrivateFieldGet$p(this, _WatchTower_listeners, "f").add(listener);
        return collector();
    }
    stateTree(state) {
        return new StateTree(state, () => this.dispatch());
    }
}
_WatchTower_signals = new WeakMap(), _WatchTower_computeds = new WeakMap(), _WatchTower_listeners = new WeakMap(), _WatchTower_memory = new WeakMap();

var ob;
(function (ob) {
    ob.map = (o, transform) => (Object.fromEntries(Object.entries(o)
        .map(([key, value]) => [key, transform(value, key)])));
    ob.filter = (o, judge) => Object.fromEntries(Object.entries(o)
        .filter(([key, value]) => judge(value, key)));
    (function (pipe) {
        pipe.map = (transform) => ((o) => ob.map(o, transform));
        pipe.filter = (transform) => ((o) => ob.filter(o, transform));
    })(ob.pipe || (ob.pipe = {}));
})(ob || (ob = {}));

const accessed = Symbol();

class SignalCircularError extends Error {
    constructor() {
        super(...arguments);
        this.name = this.constructor.name;
    }
}

var __classPrivateFieldSet$l = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$o = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Signal_value, _Signal_lock, _Signal_wait, _Signal_listeners, _Signal_invoke_listeners, _a$2;
class Signal {
    constructor(v) {
        _Signal_value.set(this, void 0);
        _Signal_lock.set(this, false);
        _Signal_wait.set(this, void 0);
        _Signal_listeners.set(this, new Set());
        this[_a$2] = false;
        _Signal_invoke_listeners.set(this, debounce(0, () => {
            const value = __classPrivateFieldGet$o(this, _Signal_value, "f");
            __classPrivateFieldSet$l(this, _Signal_lock, true, "f");
            for (const listener of __classPrivateFieldGet$o(this, _Signal_listeners, "f"))
                listener(value);
            __classPrivateFieldSet$l(this, _Signal_lock, false, "f");
            return value;
        }));
        __classPrivateFieldSet$l(this, _Signal_value, v, "f");
        __classPrivateFieldSet$l(this, _Signal_wait, Promise.resolve(v), "f");
    }
    subscribe(listener) {
        __classPrivateFieldGet$o(this, _Signal_listeners, "f").add(listener);
        return () => void __classPrivateFieldGet$o(this, _Signal_listeners, "f").delete(listener);
    }
    once(listener) {
        const actual_listener = v => {
            listener(v);
            __classPrivateFieldGet$o(this, _Signal_listeners, "f").delete(actual_listener);
        };
        __classPrivateFieldGet$o(this, _Signal_listeners, "f").add(actual_listener);
        return () => void __classPrivateFieldGet$o(this, _Signal_listeners, "f").delete(actual_listener);
    }
    clear() {
        return __classPrivateFieldGet$o(this, _Signal_listeners, "f").clear();
    }
    async publish() {
        __classPrivateFieldSet$l(this, _Signal_wait, __classPrivateFieldGet$o(this, _Signal_invoke_listeners, "f").call(this), "f");
        await __classPrivateFieldGet$o(this, _Signal_wait, "f");
    }
    get wait() {
        return __classPrivateFieldGet$o(this, _Signal_wait, "f");
    }
    get value() {
        this[accessed] = true;
        return __classPrivateFieldGet$o(this, _Signal_value, "f");
    }
    set value(s) {
        if (__classPrivateFieldGet$o(this, _Signal_lock, "f"))
            throw new SignalCircularError("you can't set a signal in a signal's subscription listener (infinite loop forbidden)");
        __classPrivateFieldSet$l(this, _Signal_value, s, "f");
        this.publish();
    }
}
_Signal_value = new WeakMap(), _Signal_lock = new WeakMap(), _Signal_wait = new WeakMap(), _Signal_listeners = new WeakMap(), _Signal_invoke_listeners = new WeakMap(), _a$2 = accessed;

class OpSignal extends Signal {
    constructor() {
        super(Op.loading());
    }
    async run(operation) {
        return Op.run(op => this.value = op, operation);
    }
    setLoading() {
        this.value = Op.loading();
    }
    setError(reason) {
        this.value = Op.error(reason);
    }
    setReady(payload) {
        this.value = Op.ready(payload);
    }
    get loading() {
        return Op.is.loading(this.value);
    }
    get error() {
        return Op.is.error(this.value);
    }
    get ready() {
        return Op.is.ready(this.value);
    }
    get payload() {
        return Op.payload(this.value);
    }
    select(choices) {
        return Op.select(this.value, choices);
    }
}

var __classPrivateFieldSet$k = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$n = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SignalTracker_instances, _SignalTracker_active, _SignalTracker_all_signals, _SignalTracker_waiters, _SignalTracker_relevant_signals, _SignalTracker_stoppers, _SignalTracker_actuate, _SignalTracker_reset_all_signals_accessed_indicator, _SignalTracker_signals_that_should_be_tracked_get;
class SignalTracker {
    constructor({ all_signals, waiters, }) {
        _SignalTracker_instances.add(this);
        _SignalTracker_active.set(this, true);
        _SignalTracker_all_signals.set(this, void 0);
        _SignalTracker_waiters.set(this, void 0);
        _SignalTracker_relevant_signals.set(this, new Set());
        _SignalTracker_stoppers.set(this, new Set());
        _SignalTracker_actuate.set(this, debounce(0, (track) => {
            if (__classPrivateFieldGet$n(this, _SignalTracker_active, "f")) {
                if ("lean" in track)
                    track.actor();
                else {
                    const { payload, recording } = this.observe(track.collector);
                    this.add_listeners(track, recording);
                    if (track.responder)
                        track.responder(payload);
                }
            }
        }));
        __classPrivateFieldSet$k(this, _SignalTracker_all_signals, all_signals, "f");
        __classPrivateFieldSet$k(this, _SignalTracker_waiters, waiters, "f");
    }
    observe(collector) {
        __classPrivateFieldGet$n(this, _SignalTracker_instances, "m", _SignalTracker_reset_all_signals_accessed_indicator).call(this);
        const payload = collector();
        return {
            payload,
            recording: __classPrivateFieldGet$n(this, _SignalTracker_instances, "a", _SignalTracker_signals_that_should_be_tracked_get),
        };
    }
    add_listeners(track, recording) {
        for (const signal of recording) {
            __classPrivateFieldGet$n(this, _SignalTracker_relevant_signals, "f").add(signal);
            __classPrivateFieldGet$n(this, _SignalTracker_stoppers, "f").add(signal.subscribe(() => __classPrivateFieldGet$n(this, _SignalTracker_waiters, "f").add(__classPrivateFieldGet$n(this, _SignalTracker_actuate, "f").call(this, track))));
        }
    }
    shutdown() {
        __classPrivateFieldSet$k(this, _SignalTracker_active, false, "f");
        __classPrivateFieldGet$n(this, _SignalTracker_stoppers, "f").forEach(stop => stop());
    }
}
_SignalTracker_active = new WeakMap(), _SignalTracker_all_signals = new WeakMap(), _SignalTracker_waiters = new WeakMap(), _SignalTracker_relevant_signals = new WeakMap(), _SignalTracker_stoppers = new WeakMap(), _SignalTracker_actuate = new WeakMap(), _SignalTracker_instances = new WeakSet(), _SignalTracker_reset_all_signals_accessed_indicator = function _SignalTracker_reset_all_signals_accessed_indicator() {
    for (const signal of __classPrivateFieldGet$n(this, _SignalTracker_all_signals, "f"))
        signal[accessed] = false;
}, _SignalTracker_signals_that_should_be_tracked_get = function _SignalTracker_signals_that_should_be_tracked_get() {
    return [...__classPrivateFieldGet$n(this, _SignalTracker_all_signals, "f")].filter(signal => (signal[accessed] &&
        !__classPrivateFieldGet$n(this, _SignalTracker_relevant_signals, "f").has(signal)));
};

var __classPrivateFieldGet$m = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SignalTower_signals, _SignalTower_waiters;
class SignalTower {
    constructor() {
        // TODO wrap all signals in WeakRef, to promote garbage collection?
        _SignalTower_signals.set(this, new Set());
        _SignalTower_waiters.set(this, new Set());
    }
    signal(value) {
        const signal = new Signal(value);
        __classPrivateFieldGet$m(this, _SignalTower_signals, "f").add(signal);
        return signal;
    }
    computed(fun) {
        const signal = this.signal(fun());
        this.reaction(() => { signal.value = fun(); });
        return signal;
    }
    op() {
        const signal = new OpSignal();
        __classPrivateFieldGet$m(this, _SignalTower_signals, "f").add(signal);
        return signal;
    }
    many(states) {
        return (ob.map(states, state => this.signal(state)));
    }
    reaction(collector, responder) {
        const tracker = new SignalTracker({
            waiters: __classPrivateFieldGet$m(this, _SignalTower_waiters, "f"),
            all_signals: __classPrivateFieldGet$m(this, _SignalTower_signals, "f"),
        });
        const track = { collector, responder };
        const { recording } = tracker.observe(track.collector);
        tracker.add_listeners(track, recording);
        return () => tracker.shutdown();
    }
    lean(actor) {
        const tracker = new SignalTracker({
            waiters: __classPrivateFieldGet$m(this, _SignalTower_waiters, "f"),
            all_signals: __classPrivateFieldGet$m(this, _SignalTower_signals, "f"),
        });
        const track = { lean: true, actor };
        return {
            stop: () => tracker.shutdown(),
            collect: collector => {
                const { payload, recording } = tracker.observe(collector);
                tracker.add_listeners(track, recording);
                return payload;
            },
        };
    }
    get wait() {
        return Promise.all([...__classPrivateFieldGet$m(this, _SignalTower_signals, "f")].map(s => s.wait))
            .then(() => Promise.all([...__classPrivateFieldGet$m(this, _SignalTower_waiters, "f")]))
            .then(() => { __classPrivateFieldGet$m(this, _SignalTower_waiters, "f").clear(); });
    }
}
_SignalTower_signals = new WeakMap(), _SignalTower_waiters = new WeakMap();

const flat = new Flat();
const signals = new SignalTower();
const watch = new WatchTower(signals);
flat.state.bind(flat);
signals.signal.bind(signals);
const reactor = new Reactor(flat, signals);

/**
 * Convert a camel-case name into a dashed name
 * - for example
 *       dashify("BigManStyle")
 *        // "big-man-style"
 */
function dashify(camel) {
    return camel.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();
}

function explode_promise() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });
    return { promise, resolve, reject };
}

var __classPrivateFieldSet$j = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$l = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Pipe_input;
class Pipe {
    static with(input) {
        return new this(input);
    }
    constructor(input) {
        _Pipe_input.set(this, void 0);
        __classPrivateFieldSet$j(this, _Pipe_input, input, "f");
    }
    to(fun) {
        return new Pipe(fun(__classPrivateFieldGet$l(this, _Pipe_input, "f")));
    }
    done() {
        return __classPrivateFieldGet$l(this, _Pipe_input, "f");
    }
}
_Pipe_input = new WeakMap();

function pub() {
    const listeners = new Set();
    function subscribe(listener) {
        listeners.add(listener);
        return () => void listeners.delete(listener);
    }
    subscribe.publish = (x) => {
        for (const listener of listeners)
            listener(x);
    };
    subscribe.clear = () => listeners.clear();
    subscribe.once = (listener) => {
        const actual_listener = (x) => {
            listener(x);
            listeners.delete(actual_listener);
        };
        listeners.add(actual_listener);
        return () => void listeners.delete(actual_listener);
    };
    return subscribe;
}

var ZipAction;
(function (ZipAction) {
    function actualize(tree, blueprint) {
        return ob.map(blueprint, value => {
            if (typeof value === "function") {
                return (...params) => {
                    tree.transmute(state => {
                        const setState = (newState) => { state = newState; };
                        value(state, setState)(...params);
                        return state;
                    });
                };
            }
            else {
                return actualize(tree, value);
            }
        });
    }
    ZipAction.actualize = actualize;
    function fn() {
        return (fn) => fn;
    }
    ZipAction.fn = fn;
    function blueprint() {
        return (blueprint) => blueprint;
    }
    ZipAction.blueprint = blueprint;
    ZipAction.prepFn = (helpers) => (fun) => ((state, setState) => (...params) => {
        fun(helpers(state, setState))(...params);
        return state;
    });
    ZipAction.prepBlueprint = (helpers) => (makeBp) => (makeBp(ZipAction.prepFn(helpers)));
    function prep(helpers) {
        return {
            action: ZipAction.prepFn(helpers),
            blueprint: ZipAction.prepBlueprint(helpers),
        };
    }
    ZipAction.prep = prep;
})(ZipAction || (ZipAction = {}));

function attributes(element, spec) {
    Attributes.on_change(element, () => element.requestUpdate());
    return Attributes.proxy(element, spec);
}
var Attributes;
(function (Attributes) {
    Attributes.proxy = (element, spec) => new Proxy(spec, {
        get: (_target, name) => {
            const type = spec[name];
            const raw = element.getAttribute(name);
            switch (type) {
                case String:
                    return raw !== null && raw !== void 0 ? raw : undefined;
                case Number:
                    return raw !== null
                        ? Number(raw)
                        : undefined;
                case Boolean:
                    return raw !== null;
                default:
                    throw new Error(`invalid attribute type for "${name}"`);
            }
        },
        set: (_target, name, value) => {
            const type = spec[name];
            switch (type) {
                case String: {
                    element.setAttribute(name, value);
                    return true;
                }
                case Number: {
                    element.setAttribute(name, value.toString());
                    return true;
                }
                case Boolean: {
                    if (value)
                        element.setAttribute(name, "");
                    else
                        element.removeAttribute(name);
                    return true;
                }
                default:
                    throw new Error(`invalid attribute type for "${name}"`);
            }
        },
    });
    function on_change(element, handle_change) {
        const observer = new MutationObserver(handle_change);
        observer.observe(element, { attributes: true });
        return () => observer.disconnect();
    }
    Attributes.on_change = on_change;
})(Attributes || (Attributes = {}));

var __classPrivateFieldGet$k = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$i = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var mixin;
(function (mixin) {
    function css(...newStyles) {
        return function (Base) {
            return class extends Base {
                static get styles() {
                    return combineStyles(Base.styles, newStyles);
                }
            };
        };
    }
    mixin.css = css;
    function css_deferred(getNewStyles) {
        return function (Base) {
            return class extends Base {
                static get styles() {
                    return combineStyles(Base.styles, getNewStyles());
                }
            };
        };
    }
    mixin.css_deferred = css_deferred;
    function signals(signals) {
        return function (Base) {
            var _lean, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _lean.set(this, null);
                    }
                    render() {
                        var _b;
                        return (_b = __classPrivateFieldGet$k(this, _lean, "f")) === null || _b === void 0 ? void 0 : _b.collect(() => super.render());
                    }
                    connectedCallback() {
                        super.connectedCallback();
                        __classPrivateFieldSet$i(this, _lean, signals.lean(() => this.requestUpdate()), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        if (__classPrivateFieldGet$k(this, _lean, "f")) {
                            __classPrivateFieldGet$k(this, _lean, "f").stop();
                            __classPrivateFieldSet$i(this, _lean, null, "f");
                        }
                    }
                },
                _lean = new WeakMap(),
                _a;
        };
    }
    mixin.signals = signals;
    function flat(flat) {
        return function (Base) {
            var _lean_1, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _lean_1.set(this, null);
                    }
                    render() {
                        var _b;
                        return (_b = __classPrivateFieldGet$k(this, _lean_1, "f")) === null || _b === void 0 ? void 0 : _b.collect(() => super.render());
                    }
                    connectedCallback() {
                        super.connectedCallback();
                        __classPrivateFieldSet$i(this, _lean_1, flat.lean(() => this.requestUpdate()), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        if (__classPrivateFieldGet$k(this, _lean_1, "f")) {
                            __classPrivateFieldGet$k(this, _lean_1, "f").stop();
                            __classPrivateFieldSet$i(this, _lean_1, null, "f");
                        }
                    }
                },
                _lean_1 = new WeakMap(),
                _a;
        };
    }
    mixin.flat = flat;
    function reactor$1(r = reactor) {
        return function (Base) {
            var _lean_2, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _lean_2.set(this, null);
                    }
                    render() {
                        var _b;
                        return (_b = __classPrivateFieldGet$k(this, _lean_2, "f")) === null || _b === void 0 ? void 0 : _b.collect(() => super.render());
                    }
                    connectedCallback() {
                        super.connectedCallback();
                        __classPrivateFieldSet$i(this, _lean_2, r.lean(() => this.requestUpdate()), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        if (__classPrivateFieldGet$k(this, _lean_2, "f")) {
                            __classPrivateFieldGet$k(this, _lean_2, "f").stop();
                            __classPrivateFieldSet$i(this, _lean_2, null, "f");
                        }
                    }
                },
                _lean_2 = new WeakMap(),
                _a;
        };
    }
    mixin.reactor = reactor$1;
})(mixin || (mixin = {}));
function arrayize(item) {
    return [item].flat().filter(i => !!i);
}
const notUndefined = (x) => x !== undefined;
function combineStyles(parentStyles, newStyles) {
    var _a;
    const styles = [
        ...((_a = arrayize(parentStyles)) !== null && _a !== void 0 ? _a : []),
        ...arrayize(newStyles),
    ];
    return styles
        .flat()
        .filter(notUndefined);
}

var apply;
(function (apply) {
    apply.css = ((theme) => ((elements) => (ob.map(elements, Element => mixin.css(theme)(Element)))));
    apply.flat = ((flat) => ((elements) => (ob.map(elements, (Element) => mixin.flat(flat)(Element)))));
    apply.signals = ((signals) => ((elements) => (ob.map(elements, (Element) => mixin.signals(signals)(Element)))));
    apply.reactor = ((r = reactor) => ((elements) => (ob.map(elements, (Element) => mixin.reactor(r)(Element)))));
    apply.context = ((context) => ((elements) => Pipe.with(elements)
        .to(apply.css(context.theme))
        .to(apply.reactor())
        .done()));
})(apply || (apply = {}));

const register_to_dom = (elements) => {
    for (const [name, Element] of Object.entries(elements))
        customElements.define(dashify(name), Element);
};

/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2=globalThis,e$4=t$2.ShadowRoot&&(void 0===t$2.ShadyCSS||t$2.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$3=Symbol(),o$4=new WeakMap;let n$3 = class n{constructor(t,e,o){if(this._$cssResult$=!0,o!==s$3)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=e;}get styleSheet(){let t=this.o;const s=this.t;if(e$4&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=o$4.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&o$4.set(s,t));}return t}toString(){return this.cssText}};const r$4=t=>new n$3("string"==typeof t?t:t+"",void 0,s$3),i$3=(t,...e)=>{const o=1===t.length?t[0]:e.reduce(((e,s,o)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(s)+t[o+1]),t[0]);return new n$3(o,t,s$3)},S$1=(s,o)=>{if(e$4)s.adoptedStyleSheets=o.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet));else for(const e of o){const o=document.createElement("style"),n=t$2.litNonce;void 0!==n&&o.setAttribute("nonce",n),o.textContent=e.cssText,s.appendChild(o);}},c$3=e$4?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const s of t.cssRules)e+=s.cssText;return r$4(e)})(t):t;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{is:i$2,defineProperty:e$3,getOwnPropertyDescriptor:r$3,getOwnPropertyNames:h$2,getOwnPropertySymbols:o$3,getPrototypeOf:n$2}=Object,a$1=globalThis,c$2=a$1.trustedTypes,l$1=c$2?c$2.emptyScript:"",p$1=a$1.reactiveElementPolyfillSupport,d$1=(t,s)=>t,u$1={toAttribute(t,s){switch(s){case Boolean:t=t?l$1:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,s){let i=t;switch(s){case Boolean:i=null!==t;break;case Number:i=null===t?null:Number(t);break;case Object:case Array:try{i=JSON.parse(t);}catch(t){i=null;}}return i}},f$3=(t,s)=>!i$2(t,s),y$1={attribute:!0,type:String,converter:u$1,reflect:!1,hasChanged:f$3};Symbol.metadata??=Symbol("metadata"),a$1.litPropertyMetadata??=new WeakMap;let b$1 = class b extends HTMLElement{static addInitializer(t){this._$Ei(),(this.l??=[]).push(t);}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(t,s=y$1){if(s.state&&(s.attribute=!1),this._$Ei(),this.elementProperties.set(t,s),!s.noAccessor){const i=Symbol(),r=this.getPropertyDescriptor(t,i,s);void 0!==r&&e$3(this.prototype,t,r);}}static getPropertyDescriptor(t,s,i){const{get:e,set:h}=r$3(this.prototype,t)??{get(){return this[s]},set(t){this[s]=t;}};return {get(){return e?.call(this)},set(s){const r=e?.call(this);h.call(this,s),this.requestUpdate(t,r,i);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)??y$1}static _$Ei(){if(this.hasOwnProperty(d$1("elementProperties")))return;const t=n$2(this);t.finalize(),void 0!==t.l&&(this.l=[...t.l]),this.elementProperties=new Map(t.elementProperties);}static finalize(){if(this.hasOwnProperty(d$1("finalized")))return;if(this.finalized=!0,this._$Ei(),this.hasOwnProperty(d$1("properties"))){const t=this.properties,s=[...h$2(t),...o$3(t)];for(const i of s)this.createProperty(i,t[i]);}const t=this[Symbol.metadata];if(null!==t){const s=litPropertyMetadata.get(t);if(void 0!==s)for(const[t,i]of s)this.elementProperties.set(t,i);}this._$Eh=new Map;for(const[t,s]of this.elementProperties){const i=this._$Eu(t,s);void 0!==i&&this._$Eh.set(i,t);}this.elementStyles=this.finalizeStyles(this.styles);}static finalizeStyles(s){const i=[];if(Array.isArray(s)){const e=new Set(s.flat(1/0).reverse());for(const s of e)i.unshift(c$3(s));}else void 0!==s&&i.push(c$3(s));return i}static _$Eu(t,s){const i=s.attribute;return !1===i?void 0:"string"==typeof i?i:"string"==typeof t?t.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Em=null,this._$Ev();}_$Ev(){this._$Eg=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$ES(),this.requestUpdate(),this.constructor.l?.forEach((t=>t(this)));}addController(t){(this._$E_??=new Set).add(t),void 0!==this.renderRoot&&this.isConnected&&t.hostConnected?.();}removeController(t){this._$E_?.delete(t);}_$ES(){const t=new Map,s=this.constructor.elementProperties;for(const i of s.keys())this.hasOwnProperty(i)&&(t.set(i,this[i]),delete this[i]);t.size>0&&(this._$Ep=t);}createRenderRoot(){const t=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return S$1(t,this.constructor.elementStyles),t}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(!0),this._$E_?.forEach((t=>t.hostConnected?.()));}enableUpdating(t){}disconnectedCallback(){this._$E_?.forEach((t=>t.hostDisconnected?.()));}attributeChangedCallback(t,s,i){this._$AK(t,i);}_$EO(t,s){const i=this.constructor.elementProperties.get(t),e=this.constructor._$Eu(t,i);if(void 0!==e&&!0===i.reflect){const r=(void 0!==i.converter?.toAttribute?i.converter:u$1).toAttribute(s,i.type);this._$Em=t,null==r?this.removeAttribute(e):this.setAttribute(e,r),this._$Em=null;}}_$AK(t,s){const i=this.constructor,e=i._$Eh.get(t);if(void 0!==e&&this._$Em!==e){const t=i.getPropertyOptions(e),r="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==t.converter?.fromAttribute?t.converter:u$1;this._$Em=e,this[e]=r.fromAttribute(s,t.type),this._$Em=null;}}requestUpdate(t,s,i,e=!1,r){if(void 0!==t){if(i??=this.constructor.getPropertyOptions(t),!(i.hasChanged??f$3)(e?r:this[t],s))return;this.C(t,s,i);}!1===this.isUpdatePending&&(this._$Eg=this._$EP());}C(t,s,i){this._$AL.has(t)||this._$AL.set(t,s),!0===i.reflect&&this._$Em!==t&&(this._$Ej??=new Set).add(t);}async _$EP(){this.isUpdatePending=!0;try{await this._$Eg;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this.renderRoot??=this.createRenderRoot(),this._$Ep){for(const[t,s]of this._$Ep)this[t]=s;this._$Ep=void 0;}const t=this.constructor.elementProperties;if(t.size>0)for(const[s,i]of t)!0!==i.wrapped||this._$AL.has(s)||void 0===this[s]||this.C(s,this[s],i);}let t=!1;const s=this._$AL;try{t=this.shouldUpdate(s),t?(this.willUpdate(s),this._$E_?.forEach((t=>t.hostUpdate?.())),this.update(s)):this._$ET();}catch(s){throw t=!1,this._$ET(),s}t&&this._$AE(s);}willUpdate(t){}_$AE(t){this._$E_?.forEach((t=>t.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$ET(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$Eg}shouldUpdate(t){return !0}update(t){this._$Ej&&=this._$Ej.forEach((t=>this._$EO(t,this[t]))),this._$ET();}updated(t){}firstUpdated(t){}};b$1.elementStyles=[],b$1.shadowRootOptions={mode:"open"},b$1[d$1("elementProperties")]=new Map,b$1[d$1("finalized")]=new Map,p$1?.({ReactiveElement:b$1}),(a$1.reactiveElementVersions??=[]).push("2.0.2");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1=globalThis,i$1=t$1.trustedTypes,s$2=i$1?i$1.createPolicy("lit-html",{createHTML:t=>t}):void 0,e$2="$lit$",h$1=`lit$${(Math.random()+"").slice(9)}$`,o$2="?"+h$1,n$1=`<${o$2}>`,r$2=document,l=()=>r$2.createComment(""),c$1=t=>null===t||"object"!=typeof t&&"function"!=typeof t,a=Array.isArray,u=t=>a(t)||"function"==typeof t?.[Symbol.iterator],d="[ \t\n\f\r]",f$2=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v=/-->/g,_=/>/g,m=RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),p=/'/g,g=/"/g,$=/^(?:script|style|textarea|title)$/i,y=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=y(1),b=y(2),w=Symbol.for("lit-noChange"),T=Symbol.for("lit-nothing"),A=new WeakMap,E=r$2.createTreeWalker(r$2,129);function C(t,i){if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==s$2?s$2.createHTML(i):i}const P=(t,i)=>{const s=t.length-1,o=[];let r,l=2===i?"<svg>":"",c=f$2;for(let i=0;i<s;i++){const s=t[i];let a,u,d=-1,y=0;for(;y<s.length&&(c.lastIndex=y,u=c.exec(s),null!==u);)y=c.lastIndex,c===f$2?"!--"===u[1]?c=v:void 0!==u[1]?c=_:void 0!==u[2]?($.test(u[2])&&(r=RegExp("</"+u[2],"g")),c=m):void 0!==u[3]&&(c=m):c===m?">"===u[0]?(c=r??f$2,d=-1):void 0===u[1]?d=-2:(d=c.lastIndex-u[2].length,a=u[1],c=void 0===u[3]?m:'"'===u[3]?g:p):c===g||c===p?c=m:c===v||c===_?c=f$2:(c=m,r=void 0);const x=c===m&&t[i+1].startsWith("/>")?" ":"";l+=c===f$2?s+n$1:d>=0?(o.push(a),s.slice(0,d)+e$2+s.slice(d)+h$1+x):s+h$1+(-2===d?i:x);}return [C(t,l+(t[s]||"<?>")+(2===i?"</svg>":"")),o]};class V{constructor({strings:t,_$litType$:s},n){let r;this.parts=[];let c=0,a=0;const u=t.length-1,d=this.parts,[f,v]=P(t,s);if(this.el=V.createElement(f,n),E.currentNode=this.el.content,2===s){const t=this.el.content.firstChild;t.replaceWith(...t.childNodes);}for(;null!==(r=E.nextNode())&&d.length<u;){if(1===r.nodeType){if(r.hasAttributes())for(const t of r.getAttributeNames())if(t.endsWith(e$2)){const i=v[a++],s=r.getAttribute(t).split(h$1),e=/([.?@])?(.*)/.exec(i);d.push({type:1,index:c,name:e[2],strings:s,ctor:"."===e[1]?k:"?"===e[1]?H:"@"===e[1]?I:R}),r.removeAttribute(t);}else t.startsWith(h$1)&&(d.push({type:6,index:c}),r.removeAttribute(t));if($.test(r.tagName)){const t=r.textContent.split(h$1),s=t.length-1;if(s>0){r.textContent=i$1?i$1.emptyScript:"";for(let i=0;i<s;i++)r.append(t[i],l()),E.nextNode(),d.push({type:2,index:++c});r.append(t[s],l());}}}else if(8===r.nodeType)if(r.data===o$2)d.push({type:2,index:c});else {let t=-1;for(;-1!==(t=r.data.indexOf(h$1,t+1));)d.push({type:7,index:c}),t+=h$1.length-1;}c++;}}static createElement(t,i){const s=r$2.createElement("template");return s.innerHTML=t,s}}function N(t,i,s=t,e){if(i===w)return i;let h=void 0!==e?s._$Co?.[e]:s._$Cl;const o=c$1(i)?void 0:i._$litDirective$;return h?.constructor!==o&&(h?._$AO?.(!1),void 0===o?h=void 0:(h=new o(t),h._$AT(t,s,e)),void 0!==e?(s._$Co??=[])[e]=h:s._$Cl=h),void 0!==h&&(i=N(t,h._$AS(t,i.values),h,e)),i}class S{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){const{el:{content:i},parts:s}=this._$AD,e=(t?.creationScope??r$2).importNode(i,!0);E.currentNode=e;let h=E.nextNode(),o=0,n=0,l=s[0];for(;void 0!==l;){if(o===l.index){let i;2===l.type?i=new M(h,h.nextSibling,this,t):1===l.type?i=new l.ctor(h,l.name,l.strings,this,t):6===l.type&&(i=new L(h,this,t)),this._$AV.push(i),l=s[++n];}o!==l?.index&&(h=E.nextNode(),o++);}return E.currentNode=r$2,e}p(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class M{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(t,i,s,e){this.type=2,this._$AH=T,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cv=e?.isConnected??!0;}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t?.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=N(this,t,i),c$1(t)?t===T||null==t||""===t?(this._$AH!==T&&this._$AR(),this._$AH=T):t!==this._$AH&&t!==w&&this._(t):void 0!==t._$litType$?this.g(t):void 0!==t.nodeType?this.$(t):u(t)?this.T(t):this._(t);}k(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}$(t){this._$AH!==t&&(this._$AR(),this._$AH=this.k(t));}_(t){this._$AH!==T&&c$1(this._$AH)?this._$AA.nextSibling.data=t:this.$(r$2.createTextNode(t)),this._$AH=t;}g(t){const{values:i,_$litType$:s}=t,e="number"==typeof s?this._$AC(t):(void 0===s.el&&(s.el=V.createElement(C(s.h,s.h[0]),this.options)),s);if(this._$AH?._$AD===e)this._$AH.p(i);else {const t=new S(e,this),s=t.u(this.options);t.p(i),this.$(s),this._$AH=t;}}_$AC(t){let i=A.get(t.strings);return void 0===i&&A.set(t.strings,i=new V(t)),i}T(t){a(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const h of t)e===i.length?i.push(s=new M(this.k(l()),this.k(l()),this,this.options)):s=i[e],s._$AI(h),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){for(this._$AP?.(!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){void 0===this._$AM&&(this._$Cv=t,this._$AP?.(t));}}class R{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(t,i,s,e,h){this.type=1,this._$AH=T,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=h,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=T;}_$AI(t,i=this,s,e){const h=this.strings;let o=!1;if(void 0===h)t=N(this,t,i,0),o=!c$1(t)||t!==this._$AH&&t!==w,o&&(this._$AH=t);else {const e=t;let n,r;for(t=h[0],n=0;n<h.length-1;n++)r=N(this,e[s+n],i,n),r===w&&(r=this._$AH[n]),o||=!c$1(r)||r!==this._$AH[n],r===T?t=T:t!==T&&(t+=(r??"")+h[n+1]),this._$AH[n]=r;}o&&!e&&this.O(t);}O(t){t===T?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,t??"");}}class k extends R{constructor(){super(...arguments),this.type=3;}O(t){this.element[this.name]=t===T?void 0:t;}}class H extends R{constructor(){super(...arguments),this.type=4;}O(t){this.element.toggleAttribute(this.name,!!t&&t!==T);}}class I extends R{constructor(t,i,s,e,h){super(t,i,s,e,h),this.type=5;}_$AI(t,i=this){if((t=N(this,t,i,0)??T)===w)return;const s=this._$AH,e=t===T&&s!==T||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,h=t!==T&&(s===T||e);e&&this.element.removeEventListener(this.name,this,s),h&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){"function"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,t):this._$AH.handleEvent(t);}}class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){N(this,t);}}const Z=t$1.litHtmlPolyfillSupport;Z?.(V,M),(t$1.litHtmlVersions??=[]).push("3.1.0");const j=(t,i,s)=>{const e=s?.renderBefore??i;let h=e._$litPart$;if(void 0===h){const t=s?.renderBefore??null;e._$litPart$=h=new M(i.insertBefore(l(),t),t,void 0,s??{});}return h._$AI(t),h};

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */let s$1 = class s extends b$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0;}createRenderRoot(){const t=super.createRenderRoot();return this.renderOptions.renderBefore??=t.firstChild,t}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=j(i,this.renderRoot,this.renderOptions);}connectedCallback(){super.connectedCallback(),this._$Do?.setConnected(!0);}disconnectedCallback(){super.disconnectedCallback(),this._$Do?.setConnected(!1);}render(){return w}};s$1._$litElement$=!0,s$1[("finalized")]=!0,globalThis.litElementHydrateSupport?.({LitElement:s$1});const r$1=globalThis.litElementPolyfillSupport;r$1?.({LitElement:s$1});(globalThis.litElementVersions??=[]).push("4.0.2");

var __classPrivateFieldGet$j = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
function mixinSetups(Base) {
    var _setups, _setdowns, _a;
    return _a = class extends Base {
            constructor() {
                super(...arguments);
                _setups.set(this, new Set()
                    .add(() => this.setup()));
                _setdowns.set(this, new Set());
            }
            register_setup(setup) {
                __classPrivateFieldGet$j(this, _setups, "f").add(setup);
            }
            setup() {
                return () => { };
            }
            connectedCallback() {
                for (const setup of __classPrivateFieldGet$j(this, _setups, "f"))
                    __classPrivateFieldGet$j(this, _setdowns, "f").add(setup());
            }
            disconnectedCallback() {
                for (const setdown of __classPrivateFieldGet$j(this, _setdowns, "f"))
                    setdown();
                __classPrivateFieldGet$j(this, _setdowns, "f").clear();
            }
        },
        _setups = new WeakMap(),
        _setdowns = new WeakMap(),
        _a;
}

class MetallicElement extends mixinSetups(HTMLElement) {
}

function finalize_styles(styles) {
    const elementStyles = [];
    if (Array.isArray(styles)) {
        const set = new Set(styles.flat(Infinity).reverse());
        for (const s of set)
            elementStyles.unshift(c$3(s));
    }
    else if (styles !== undefined)
        elementStyles.push(c$3(styles));
    return elementStyles;
}

function apply_styles_to_shadow(shadow, styles) {
    S$1(shadow, finalize_styles(styles));
}

var __classPrivateFieldSet$h = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$i = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GoldElement_root, _GoldElement_init, _GoldElement_wait, _GoldElement_render_debounced;
class GoldElement extends MetallicElement {
    static get styles() { return undefined; }
    init() { }
    constructor() {
        super();
        _GoldElement_root.set(this, void 0);
        _GoldElement_init.set(this, explode_promise());
        _GoldElement_wait.set(this, __classPrivateFieldGet$i(this, _GoldElement_init, "f").promise);
        _GoldElement_render_debounced.set(this, debounce(0, () => {
            const root = __classPrivateFieldGet$i(this, _GoldElement_root, "f");
            const template = this.render();
            if (template)
                j(template, root, { host: this });
        }));
        __classPrivateFieldSet$h(this, _GoldElement_root, this.attachShadow({ mode: "open" }), "f");
        const C = this.constructor;
        apply_styles_to_shadow(__classPrivateFieldGet$i(this, _GoldElement_root, "f"), C.styles);
        this.init();
    }
    get root() {
        return __classPrivateFieldGet$i(this, _GoldElement_root, "f");
    }
    get updateComplete() {
        return __classPrivateFieldGet$i(this, _GoldElement_wait, "f").then(() => true);
    }
    render() { }
    async requestUpdate() {
        const promise = __classPrivateFieldGet$i(this, _GoldElement_render_debounced, "f").call(this);
        if (__classPrivateFieldGet$i(this, _GoldElement_init, "f")) {
            promise.then(__classPrivateFieldGet$i(this, _GoldElement_init, "f").resolve);
            __classPrivateFieldSet$h(this, _GoldElement_init, undefined, "f");
        }
        __classPrivateFieldSet$h(this, _GoldElement_wait, promise, "f");
        return promise;
    }
    connectedCallback() {
        super.connectedCallback();
        this.requestUpdate();
    }
}
_GoldElement_root = new WeakMap(), _GoldElement_init = new WeakMap(), _GoldElement_wait = new WeakMap(), _GoldElement_render_debounced = new WeakMap();

var __classPrivateFieldGet$h = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$g = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _SilverElement_init, _SilverElement_wait, _SilverElement_render_debounced;
class SilverElement extends MetallicElement {
    init() { }
    constructor() {
        super();
        _SilverElement_init.set(this, explode_promise());
        _SilverElement_wait.set(this, __classPrivateFieldGet$h(this, _SilverElement_init, "f").promise);
        _SilverElement_render_debounced.set(this, debounce(0, () => {
            const template = this.render();
            j(template, this, { host: this });
        }));
        this.init();
    }
    get updateComplete() {
        return __classPrivateFieldGet$h(this, _SilverElement_wait, "f").then(() => true);
    }
    render() { }
    async requestUpdate() {
        const promise = __classPrivateFieldGet$h(this, _SilverElement_render_debounced, "f").call(this);
        if (__classPrivateFieldGet$h(this, _SilverElement_init, "f")) {
            promise.then(__classPrivateFieldGet$h(this, _SilverElement_init, "f").resolve);
            __classPrivateFieldSet$g(this, _SilverElement_init, undefined, "f");
        }
        __classPrivateFieldSet$g(this, _SilverElement_wait, promise, "f");
        return promise;
    }
    connectedCallback() {
        super.connectedCallback();
        this.requestUpdate();
    }
}
_SilverElement_init = new WeakMap(), _SilverElement_wait = new WeakMap(), _SilverElement_render_debounced = new WeakMap();

var __classPrivateFieldGet$g = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$f = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Use_context, _Use_rerender, _Use_counter, _Use_setups, _Use_setdowns, _Use_initStarts, _Use_initResults, _Use_initDowns, _Use_states, _Use_preparations, _Use_flatstates, _Use_signals, _Use_watches, _Counter_value;
class Use {
    static wrap(use, fun) {
        return ((...args) => {
            __classPrivateFieldGet$g(use, _Use_counter, "f").reset();
            return fun(...args);
        });
    }
    static disconnect(use) {
        // cleanup setups
        for (const down of __classPrivateFieldGet$g(use, _Use_setdowns, "f"))
            down();
        __classPrivateFieldGet$g(use, _Use_setdowns, "f").clear();
        // cleanup inits
        for (const down of __classPrivateFieldGet$g(use, _Use_initDowns, "f"))
            down();
        __classPrivateFieldGet$g(use, _Use_initDowns, "f").clear();
        __classPrivateFieldGet$g(use, _Use_initResults, "f").clear();
    }
    static reconnect(use) {
        // call all setups
        for (const up of __classPrivateFieldGet$g(use, _Use_setups, "f").values())
            __classPrivateFieldGet$g(use, _Use_setdowns, "f").add(up());
        // call all inits
        for (const [count, start] of __classPrivateFieldGet$g(use, _Use_initStarts, "f").entries()) {
            const [result, down] = start();
            __classPrivateFieldGet$g(use, _Use_initResults, "f").set(count, result);
            __classPrivateFieldGet$g(use, _Use_initDowns, "f").add(down);
        }
    }
    constructor(rerender, context) {
        _Use_context.set(this, void 0);
        _Use_rerender.set(this, void 0);
        _Use_counter.set(this, new Counter());
        _Use_setups.set(this, new Map());
        _Use_setdowns.set(this, new Set());
        _Use_initStarts.set(this, new Map());
        _Use_initResults.set(this, new Map());
        _Use_initDowns.set(this, new Set());
        _Use_states.set(this, new Map());
        _Use_preparations.set(this, new Map());
        _Use_flatstates.set(this, new Map());
        _Use_signals.set(this, new Map());
        _Use_watches.set(this, new Map());
        __classPrivateFieldSet$f(this, _Use_rerender, rerender, "f");
        __classPrivateFieldSet$f(this, _Use_context, context, "f");
    }
    get context() {
        return __classPrivateFieldGet$g(this, _Use_context, "f");
    }
    rerender() {
        __classPrivateFieldGet$g(this, _Use_rerender, "f").call(this);
    }
    setup(func) {
        const count = __classPrivateFieldGet$g(this, _Use_counter, "f").pull();
        if (!__classPrivateFieldGet$g(this, _Use_setups, "f").has(count)) {
            __classPrivateFieldGet$g(this, _Use_setups, "f").set(count, func);
            __classPrivateFieldGet$g(this, _Use_setdowns, "f").add(func());
        }
    }
    init(func) {
        const count = __classPrivateFieldGet$g(this, _Use_counter, "f").pull();
        if (!__classPrivateFieldGet$g(this, _Use_initStarts, "f").has(count)) {
            __classPrivateFieldGet$g(this, _Use_initStarts, "f").set(count, func);
            const [result, down] = func();
            __classPrivateFieldGet$g(this, _Use_initResults, "f").set(count, result);
            __classPrivateFieldGet$g(this, _Use_initDowns, "f").add(down);
            return result;
        }
        return __classPrivateFieldGet$g(this, _Use_initResults, "f").get(count);
    }
    prepare(prep) {
        const count = __classPrivateFieldGet$g(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet$g(this, _Use_preparations, "f")).grab(count, prep);
    }
    state(init) {
        const count = __classPrivateFieldGet$g(this, _Use_counter, "f").pull();
        const value = maptool(__classPrivateFieldGet$g(this, _Use_states, "f")).grab(count, () => ((typeof init === "function")
            ? init()
            : init));
        const setter = (v) => {
            __classPrivateFieldGet$g(this, _Use_states, "f").set(count, v);
            __classPrivateFieldGet$g(this, _Use_rerender, "f").call(this);
        };
        const getter = () => __classPrivateFieldGet$g(this, _Use_states, "f").get(count);
        return [value, setter, getter];
    }
    flatstate(init) {
        const count = __classPrivateFieldGet$g(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet$g(this, _Use_flatstates, "f")).grab(count, () => (flat.state((typeof init === "function")
            ? init()
            : init)));
    }
    signal(init) {
        const count = __classPrivateFieldGet$g(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet$g(this, _Use_signals, "f")).grab(count, () => (signals.signal((typeof init === "function")
            ? init()
            : init)));
    }
    computed(update) {
        const count = __classPrivateFieldGet$g(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet$g(this, _Use_signals, "f")).grab(count, () => (signals.computed(update)));
    }
    op() {
        const count = __classPrivateFieldGet$g(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet$g(this, _Use_signals, "f")).grab(count, () => signals.op());
    }
    watch(collector) {
        const count = __classPrivateFieldGet$g(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet$g(this, _Use_watches, "f")).grab(count, () => watch.track(collector, data => {
            __classPrivateFieldGet$g(this, _Use_watches, "f").set(count, data);
            __classPrivateFieldGet$g(this, _Use_rerender, "f").call(this);
        }));
    }
}
_Use_context = new WeakMap(), _Use_rerender = new WeakMap(), _Use_counter = new WeakMap(), _Use_setups = new WeakMap(), _Use_setdowns = new WeakMap(), _Use_initStarts = new WeakMap(), _Use_initResults = new WeakMap(), _Use_initDowns = new WeakMap(), _Use_states = new WeakMap(), _Use_preparations = new WeakMap(), _Use_flatstates = new WeakMap(), _Use_signals = new WeakMap(), _Use_watches = new WeakMap();
class Counter {
    constructor() {
        _Counter_value.set(this, 0);
    }
    pull() {
        var _a, _b;
        return __classPrivateFieldSet$f(this, _Counter_value, (_b = __classPrivateFieldGet$g(this, _Counter_value, "f"), _a = _b++, _b), "f"), _a;
    }
    reset() {
        __classPrivateFieldSet$f(this, _Counter_value, 0, "f");
    }
}
_Counter_value = new WeakMap();

var __classPrivateFieldGet$f = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$e = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _UseShadow_element, _UseShadow_shadow;
class UseShadow extends Use {
    get element() { return __classPrivateFieldGet$f(this, _UseShadow_element, "f"); }
    get shadow() { return __classPrivateFieldGet$f(this, _UseShadow_shadow, "f"); }
    constructor(element, shadow, rerender, context) {
        super(rerender, context);
        _UseShadow_element.set(this, void 0);
        _UseShadow_shadow.set(this, void 0);
        __classPrivateFieldSet$e(this, _UseShadow_element, element, "f");
        __classPrivateFieldSet$e(this, _UseShadow_shadow, shadow, "f");
    }
}
_UseShadow_element = new WeakMap(), _UseShadow_shadow = new WeakMap();

function setup_use_attrs(element) {
    let attrs;
    return function (spec) {
        if (!attrs)
            attrs = attributes(element, spec);
        return attrs;
    };
}

class UseGold extends UseShadow {
    constructor(element, shadow, rerender, context) {
        super(element, shadow, rerender, context);
        this.attrs = setup_use_attrs(element);
    }
}

var __classPrivateFieldGet$e = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$d = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _UseSilver_element;
class UseSilver extends Use {
    get element() { return __classPrivateFieldGet$e(this, _UseSilver_element, "f"); }
    constructor(element, rerender, context) {
        super(rerender, context);
        _UseSilver_element.set(this, void 0);
        __classPrivateFieldSet$d(this, _UseSilver_element, element, "f");
        this.attrs = setup_use_attrs(element);
    }
}
_UseSilver_element = new WeakMap();

class UseCarbon extends UseGold {
}
class UseOxygen extends UseSilver {
}
class UseQuartz extends Use {
}
class UseObsidian extends UseShadow {
}

(undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};

function setup_reactivity(render, rerender) {
    const lean = reactor.lean(rerender);
    return {
        stop: lean.stop,
        render: (...props) => lean.collect(() => render(...props)),
    };
}

var __classPrivateFieldGet$d = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$c = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
const prepare_carbon = ((shell) => (settings, renderer) => {
    var _use, _rend, _reactivity, _a;
    return _a = class extends GoldElement {
            constructor() {
                super(...arguments);
                _use.set(this, new UseCarbon(this, this.root, () => void this.requestUpdate(), shell.context));
                _rend.set(this, UseCarbon.wrap(__classPrivateFieldGet$d(this, _use, "f"), () => renderer(__classPrivateFieldGet$d(this, _use, "f"))));
                _reactivity.set(this, void 0);
            }
            static get styles() {
                var _b;
                return [
                    shell.context.theme,
                    (_b = settings.styles) !== null && _b !== void 0 ? _b : i$3 ``,
                ];
            }
            render() {
                var _b;
                return (_b = __classPrivateFieldGet$d(this, _reactivity, "f")) === null || _b === void 0 ? void 0 : _b.render();
            }
            connectedCallback() {
                super.connectedCallback();
                UseCarbon.reconnect(__classPrivateFieldGet$d(this, _use, "f"));
                __classPrivateFieldSet$c(this, _reactivity, setup_reactivity(__classPrivateFieldGet$d(this, _rend, "f"), () => void this.requestUpdate()), "f");
            }
            disconnectedCallback() {
                super.disconnectedCallback();
                UseCarbon.disconnect(__classPrivateFieldGet$d(this, _use, "f"));
                if (__classPrivateFieldGet$d(this, _reactivity, "f")) {
                    __classPrivateFieldGet$d(this, _reactivity, "f").stop();
                    __classPrivateFieldSet$c(this, _reactivity, undefined, "f");
                }
            }
        },
        _use = new WeakMap(),
        _rend = new WeakMap(),
        _reactivity = new WeakMap(),
        _a.label = settings.name,
        _a;
});

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const f$1=o=>void 0===o.strings;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},e$1=t=>(...e)=>({_$litDirective$:t,values:e});class i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i;}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const s=(i,t)=>{const e=i._$AN;if(void 0===e)return !1;for(const i of e)i._$AO?.(t,!1),s(i,t);return !0},o$1=i=>{let t,e;do{if(void 0===(t=i._$AM))break;e=t._$AN,e.delete(i),i=t;}while(0===e?.size)},r=i=>{for(let t;t=i._$AM;i=t){let e=t._$AN;if(void 0===e)t._$AN=e=new Set;else if(e.has(i))break;e.add(i),c(t);}};function h(i){void 0!==this._$AN?(o$1(this),this._$AM=i,r(this)):this._$AM=i;}function n(i,t=!1,e=0){const r=this._$AH,h=this._$AN;if(void 0!==h&&0!==h.size)if(t)if(Array.isArray(r))for(let i=e;i<r.length;i++)s(r[i],!1),o$1(r[i]);else null!=r&&(s(r,!1),o$1(r));else s(this,i);}const c=i=>{i.type==t.CHILD&&(i._$AP??=n,i._$AQ??=h);};class f extends i{constructor(){super(...arguments),this._$AN=void 0;}_$AT(i,t,e){super._$AT(i,t,e),r(this),this.isConnected=i._$AU;}_$AO(i,t=!0){i!==this.isConnected&&(this.isConnected=i,i?this.reconnected?.():this.disconnected?.()),t&&(s(this,i),o$1(this));}setValue(t){if(f$1(this._$Ct))this._$Ct._$AI(t,this);else {const i=[...this._$Ct._$AH];i[this._$Ci]=t,this._$Ct._$AI(i,this,0);}}disconnected(){}reconnected(){}}

class ObsidianView extends HTMLElement {
    constructor() {
        super(...arguments);
        this.onConnected = pub();
        this.onDisconnected = pub();
    }
    connectedCallback() {
        this.onConnected.publish();
    }
    disconnectedCallback() {
        this.onDisconnected.publish();
    }
}
ObsidianView.tag = "obsidian-view";
register_to_dom({ ObsidianView });

function parse_prefixes(...partstrings) {
    const prefixes = new Set();
    const parts = partstrings
        .map(part => part !== null && part !== void 0 ? part : "")
        .flatMap(parse_part);
    for (const part of parts)
        prefixes.add(part);
    return prefixes;
}
function query_attributes(container, attributes) {
    return Object.fromEntries(Object.entries(attributes).map(([key, attr]) => [
        key,
        Array.from(container.querySelectorAll(`[${attr}]`))
            .map(e => e.getAttribute(attr)),
    ]));
}
function parse_part(attr) {
    return attr
        .split(/\s+/)
        .map(s => s.trim())
        .filter(s => !!s);
}
function parse_exportparts(attr) {
    return attr
        .split(",")
        .map(s => s.trim())
        .filter(s => !!s)
        .map(s => s.includes(":")
        ? s.split(":").map(s => s.trim())[1]
        : s);
}
function stitch_exportparts_together(parts, gparts) {
    return ((prefix) => [...parts].flatMap(part => [
        `${part}:${prefix}-${part}`,
        ...(gparts.has(part) ? [part] : []),
    ]));
}

function auto_exportparts(container, root) {
    const prefixes = parse_prefixes(container.getAttribute("part"));
    const gprefixes = parse_prefixes(container.getAttribute("data-gpart"));
    const attrs = query_attributes(root, {
        part: "part",
        gpart: "data-gpart",
        exportparts: "exportparts",
        gexportparts: "gexportparts",
    });
    const parts = new Set([
        ...attrs.part.flatMap(parse_part),
        ...attrs.exportparts.flatMap(parse_exportparts),
    ]);
    const gparts = new Set([
        ...attrs.gpart.flatMap(parse_part),
        ...attrs.gexportparts.flatMap(parse_part),
    ]);
    if (parts.size)
        container.setAttribute("exportparts", [...prefixes]
            .flatMap(stitch_exportparts_together(parts, gparts))
            .join(", "));
    if (gparts.size || container.hasAttribute("data-gpart"))
        container.setAttribute("gexportparts", [
            ...gparts,
            ...[...gprefixes]
                .flatMap(prefix => [...parts].map(part => `${prefix}-${part}`)),
        ].join(" "));
}

function make_view_root({ name, css, onConnected, onDisconnected }) {
    const container = document.createElement(ObsidianView.tag);
    container.setAttribute("view", name);
    container.onConnected(onConnected);
    container.onDisconnected(onDisconnected);
    const shadow = container.attachShadow({ mode: "open" });
    apply_styles_to_shadow(shadow, css);
    let auto_exportparts_is_enabled = false;
    return {
        container,
        shadow,
        set auto_exportparts(enabled) {
            auto_exportparts_is_enabled = enabled;
        },
        render_into_shadow(content) {
            j(content, shadow);
            if (auto_exportparts_is_enabled)
                auto_exportparts(container, shadow);
            return container;
        },
    };
}

function apply_attributes(elements, attributes) {
    for (const [key, value] of Object.entries(attributes)) {
        if (typeof value === "string")
            elements.setAttribute(key, value);
        else if (typeof value === "number")
            elements.setAttribute(key, value.toString());
        else if (typeof value === "boolean") {
            if (value === true)
                elements.setAttribute(key, "");
            else
                elements.removeAttribute(key);
        }
        else if (typeof value === "undefined")
            elements.removeAttribute(key);
        else
            console.warn(`invalid attribute type ${key} is ${typeof value}`);
    }
}

function apply_details(element, freshMeta = {}, oldMeta = {}) {
    const { content, attrs: fresh = {} } = freshMeta;
    const { attrs: old = {} } = oldMeta;
    function actuate(freshvalue, oldvalue, name, value) {
        if (freshvalue !== oldvalue) {
            if (freshvalue === undefined)
                element.removeAttribute(name);
            else
                element.setAttribute(name, value());
        }
    }
    if (fresh)
        apply_attributes(element, fresh);
    actuate(fresh.class, old === null || old === void 0 ? void 0 : old.class, "class", () => fresh.class);
    actuate(fresh.part, old === null || old === void 0 ? void 0 : old.part, "part", () => fresh.part);
    actuate(fresh.gpart, old === null || old === void 0 ? void 0 : old.gpart, "data-gpart", () => fresh.gpart);
    if (content)
        j(content, element, { host: element });
}

const obsidian_custom_lit_directive = ((c) => ((props, meta = {}) => ({
    ['_$litDirective$']: c,
    values: [{ meta, props }],
})));

var __classPrivateFieldGet$c = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$b = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
const prepare_obsidian = ((shell) => (settings = {}, renderer) => {
    var _input, _first_connection, _root, _rerender, _use, _rend, _reactivity, _a;
    return (obsidian_custom_lit_directive((_a = class extends f {
            constructor() {
                var _b, _c;
                super(...arguments);
                _input.set(this, void 0);
                _first_connection.set(this, true);
                _root.set(this, make_view_root({
                    name: (_b = settings.name) !== null && _b !== void 0 ? _b : "",
                    css: [shell.context.theme, (_c = settings.styles) !== null && _c !== void 0 ? _c : i$3 ``],
                    onDisconnected: () => this.disconnected(),
                    onConnected: () => {
                        if (!__classPrivateFieldGet$c(this, _first_connection, "f"))
                            this.reconnected();
                        __classPrivateFieldSet$b(this, _first_connection, false, "f");
                    },
                }));
                _rerender.set(this, debounce(0, () => {
                    if (__classPrivateFieldGet$c(this, _input, "f"))
                        this.setValue(__classPrivateFieldGet$c(this, _root, "f").render_into_shadow(this.render(__classPrivateFieldGet$c(this, _input, "f"))));
                }));
                _use.set(this, new UseObsidian(__classPrivateFieldGet$c(this, _root, "f").container, __classPrivateFieldGet$c(this, _root, "f").shadow, __classPrivateFieldGet$c(this, _rerender, "f"), shell.context));
                _rend.set(this, UseObsidian.wrap(__classPrivateFieldGet$c(this, _use, "f"), renderer(__classPrivateFieldGet$c(this, _use, "f"))));
                _reactivity.set(this, setup_reactivity(__classPrivateFieldGet$c(this, _rend, "f"), __classPrivateFieldGet$c(this, _rerender, "f")));
            }
            update(_, props) {
                return __classPrivateFieldGet$c(this, _root, "f").render_into_shadow(this.render(...props));
            }
            render(input) {
                var _b, _c, _d, _e;
                apply_details(__classPrivateFieldGet$c(this, _root, "f").container, input.meta, (_b = __classPrivateFieldGet$c(this, _input, "f")) === null || _b === void 0 ? void 0 : _b.meta);
                __classPrivateFieldSet$b(this, _input, input, "f");
                __classPrivateFieldGet$c(this, _root, "f").auto_exportparts = ((_d = (_c = input.meta.auto_exportparts) !== null && _c !== void 0 ? _c : settings.auto_exportparts) !== null && _d !== void 0 ? _d : true);
                return (_e = __classPrivateFieldGet$c(this, _reactivity, "f")) === null || _e === void 0 ? void 0 : _e.render(...input.props);
            }
            reconnected() {
                UseObsidian.reconnect(__classPrivateFieldGet$c(this, _use, "f"));
                __classPrivateFieldSet$b(this, _reactivity, setup_reactivity(__classPrivateFieldGet$c(this, _rend, "f"), __classPrivateFieldGet$c(this, _rerender, "f")), "f");
            }
            disconnected() {
                UseObsidian.disconnect(__classPrivateFieldGet$c(this, _use, "f"));
                if (__classPrivateFieldGet$c(this, _reactivity, "f")) {
                    __classPrivateFieldGet$c(this, _reactivity, "f").stop();
                    __classPrivateFieldSet$b(this, _reactivity, undefined, "f");
                }
            }
        },
        _input = new WeakMap(),
        _first_connection = new WeakMap(),
        _root = new WeakMap(),
        _rerender = new WeakMap(),
        _use = new WeakMap(),
        _rend = new WeakMap(),
        _reactivity = new WeakMap(),
        _a)));
});

var __classPrivateFieldGet$b = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$a = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
const prepare_oxygen = ((shell) => (renderer) => {
    var _use, _rend, _reactivity, _a;
    return (_a = class extends SilverElement {
            constructor() {
                super(...arguments);
                _use.set(this, new UseOxygen(this, () => void this.requestUpdate(), shell.context));
                _rend.set(this, UseOxygen.wrap(__classPrivateFieldGet$b(this, _use, "f"), () => renderer(__classPrivateFieldGet$b(this, _use, "f"))));
                _reactivity.set(this, void 0);
            }
            render() {
                var _b;
                return (_b = __classPrivateFieldGet$b(this, _reactivity, "f")) === null || _b === void 0 ? void 0 : _b.render();
            }
            connectedCallback() {
                super.connectedCallback();
                __classPrivateFieldSet$a(this, _reactivity, setup_reactivity(__classPrivateFieldGet$b(this, _rend, "f"), () => void this.requestUpdate()), "f");
                UseOxygen.reconnect(__classPrivateFieldGet$b(this, _use, "f"));
            }
            disconnectedCallback() {
                super.disconnectedCallback();
                if (__classPrivateFieldGet$b(this, _reactivity, "f")) {
                    __classPrivateFieldGet$b(this, _reactivity, "f").stop();
                    __classPrivateFieldSet$a(this, _reactivity, undefined, "f");
                }
                UseOxygen.disconnect(__classPrivateFieldGet$b(this, _use, "f"));
            }
        },
        _use = new WeakMap(),
        _rend = new WeakMap(),
        _reactivity = new WeakMap(),
        _a);
});

var __classPrivateFieldSet$9 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$a = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
const prepare_quartz = ((shell) => (renderer) => {
    var _props, _rerender, _use, _rend, _reactivity, _a;
    return e$1((_a = class extends f {
            constructor() {
                super(...arguments);
                _props.set(this, void 0);
                _rerender.set(this, debounce(0, () => {
                    if (__classPrivateFieldGet$a(this, _props, "f"))
                        this.setValue(this.render(...__classPrivateFieldGet$a(this, _props, "f")));
                }));
                _use.set(this, new UseQuartz(__classPrivateFieldGet$a(this, _rerender, "f"), shell.context));
                _rend.set(this, UseQuartz.wrap(__classPrivateFieldGet$a(this, _use, "f"), renderer(__classPrivateFieldGet$a(this, _use, "f"))));
                _reactivity.set(this, setup_reactivity(__classPrivateFieldGet$a(this, _rend, "f"), __classPrivateFieldGet$a(this, _rerender, "f")));
            }
            render(...props) {
                var _b;
                __classPrivateFieldSet$9(this, _props, props, "f");
                return (_b = __classPrivateFieldGet$a(this, _reactivity, "f")) === null || _b === void 0 ? void 0 : _b.render(...props);
            }
            reconnected() {
                UseQuartz.reconnect(__classPrivateFieldGet$a(this, _use, "f"));
                __classPrivateFieldSet$9(this, _reactivity, setup_reactivity(__classPrivateFieldGet$a(this, _rend, "f"), __classPrivateFieldGet$a(this, _rerender, "f")), "f");
            }
            disconnected() {
                UseQuartz.disconnect(__classPrivateFieldGet$a(this, _use, "f"));
                if (__classPrivateFieldGet$a(this, _reactivity, "f")) {
                    __classPrivateFieldGet$a(this, _reactivity, "f").stop();
                    __classPrivateFieldSet$9(this, _reactivity, undefined, "f");
                }
            }
        },
        _props = new WeakMap(),
        _rerender = new WeakMap(),
        _use = new WeakMap(),
        _rend = new WeakMap(),
        _reactivity = new WeakMap(),
        _a));
});

let Context$1 = class Context {
    constructor() {
        this.theme = i$3 `
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}
	`;
    }
};

const html = (strings, ...values) => (x(strings, ...values.map(value => ((value instanceof Signal)
    ? value.value
    : value))));

var __classPrivateFieldSet$8 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$9 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Shell_context;
class Shell {
    constructor(context) {
        _Shell_context.set(this, void 0);
        __classPrivateFieldSet$8(this, _Shell_context, context, "f");
    }
    get context() {
        if (__classPrivateFieldGet$9(this, _Shell_context, "f"))
            return __classPrivateFieldGet$9(this, _Shell_context, "f");
        else
            throw new Error("slate.context was not set, but it's necessary");
    }
    set context(context) {
        __classPrivateFieldSet$8(this, _Shell_context, context, "f");
    }
}
_Shell_context = new WeakMap();

class Slate extends Shell {
    constructor(context) {
        super(context);
        this.light_component = prepare_oxygen(this);
        this.shadow_component = prepare_carbon(this);
        this.light_view = prepare_quartz(this);
        this.shadow_view = prepare_obsidian(this);
    }
    components(elements) {
        return apply.context(this.context)(elements);
    }
}

const defaults = {
    // 250 is shopify's maximum page size
    page_size: 250,
    api_version: "2023-04",
    image_format: "WEBP"
};

class ShopifyShepherdError extends Error {
    constructor() {
        super(...arguments);
        this.name = this.constructor.name;
    }
}
class ShopifyResponseError extends ShopifyShepherdError {
    constructor({ message, path }) {
        super(`${message} ⮞ ${path.join(" 🡪 ")}`);
    }
}
class ShopifyNotFoundError extends ShopifyShepherdError {
    constructor(subject) {
        super(`not found (${subject})`);
    }
}
class ShopifyCheckoutError extends ShopifyShepherdError {
    constructor(errors) {
        super(ShopifyCheckoutError.format(errors));
        this.errors = errors;
    }
    static format(errors) {
        return errors.map(error => `(${error.code}) ${error.field.join('.')}: ${error.message}`).join(";");
    }
}

var __classPrivateFieldSet$7 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$8 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Remote_settings;
class Remote {
    constructor(settings) {
        _Remote_settings.set(this, void 0);
        __classPrivateFieldSet$7(this, _Remote_settings, settings, "f");
    }
    async request({ query, variables }) {
        const { domain, storefront_access_token, api_version = defaults.api_version, } = __classPrivateFieldGet$8(this, _Remote_settings, "f");
        const url = `https://${domain}/api/${api_version}/graphql`;
        const method = "POST";
        const headers = {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "X-Sdk-Variant": "javascript",
            "X-Sdk-Version": "2.19.0",
            "X-Shopify-Storefront-Access-Token": storefront_access_token,
        };
        const response = await fetch(url, {
            method,
            headers,
            mode: "cors",
            body: JSON.stringify({ query, variables }),
            credentials: "omit",
        });
        const result = await response.json();
        if ("errors" in result)
            for (const error of result.errors)
                throw new ShopifyResponseError(error);
        return result.data;
    }
}
_Remote_settings = new WeakMap();

async function concurrent(o) {
    const keys = Object.keys(o);
    const awaitables = Object.values(o);
    const values = await Promise.all(awaitables);
    const result = {};
    keys.forEach((key, i) => result[key] = values[i]);
    return result;
}

async function all(generator) {
    const all = [];
    for await (const [nodes] of generator)
        for (const node of nodes)
            all.push(node);
    return all;
}

async function* paginate(fetch) {
    let after;
    let fetch_count = 0;
    const there_are_more_pages = () => !!((fetch_count === 0) || after);
    let more = true;
    while (more) {
        fetch_count += 1;
        const result = await fetch(after);
        if (!result)
            throw new ShopifyNotFoundError(`paginated resource not found`);
        const { edges, pageInfo: { hasNextPage, endCursor }, } = result;
        after = hasNextPage
            ? endCursor
            : undefined;
        const nodes = edges.map(edge => edge.node);
        more = there_are_more_pages();
        yield [nodes, more];
    }
}

async function first(generator) {
    const { value } = await generator.next();
    const [nodes] = value;
    return nodes;
}

function template_noop(strings, ...values) {
    return Array.from(strings).reduce((previous, current, index) => { var _a; return previous + current + ((_a = values[index]) !== null && _a !== void 0 ? _a : ""); }, "");
}

const gql = template_noop;

function make_request_for_shop() {
    return {
        query: gql `
			query FetchShopInfo {
				shop {
					name
					description
					shipsToCountries
					paymentSettings {
						currencyCode
						countryCode
					}
				}
			}
		`,
    };
}

const pageInfo = () => gql `
	pageInfo {
		hasNextPage
		endCursor
	}
`;
const paginated = (node) => gql `
	edges {
		node {
			${node}
		}
	}
	${pageInfo()}
`;
const paginated_node = () => gql `
	edges {
		node
	}
	${pageInfo()}
`;

function make_request_for_tags({ page_size }) {
    return {
        query: gql `
			query FetchTags($first: Int!) {
				productTags(first: $first) {
					${paginated_node()}
				}
			}
		`,
        variables: {
            first: page_size,
        },
    };
}

const edges = (node) => gql `
	edges {
		node {
			${node}
		}
	}
`;

function variants() {
    // "quantityAvailable" is omitted because it's broken on the storefront api
    //  - https://community.shopify.com/c/hydrogen-headless-and-storefront/need-unauthenticated-read-product-inventory-to-access/td-p/1955913
    return gql `
		variants(first: ${defaults.page_size}) {
			${edges(gql `

				id
				title
				availableForSale
				currentlyNotInStock

				price {
					amount
					currencyCode
				}

				compareAtPrice {
					amount
					currencyCode
				}

				image {
					id
				}

				selectedOptions {
					name
					value
				}

			`)}
		}
	`;
}

function image(format) {
    function url_with_transform(x, y) {
        return gql `
			url(
				transform: {
					maxWidth: ${x}
					maxHeight: ${y}
					preferredContentType: ${format}
				}
			)
		`;
    }
    return gql `
		id
		altText
		url_original: url
		url_tiny: ${url_with_transform(200, 200)}
		url_small: ${url_with_transform(500, 500)}
		url_medium: ${url_with_transform(1000, 1000)}
		url_large: ${url_with_transform(2000, 2000)}
	`;
}

function product({ image_format }) {
    // "totalInventory" is omitted because it triggers a shopify bug
    //  - https://community.shopify.com/c/hydrogen-headless-and-storefront/need-unauthenticated-read-product-inventory-to-access/td-p/1955913
    return gql `
		availableForSale
		createdAt
		description
		descriptionHtml
		handle
		id
		isGiftCard
		onlineStoreUrl
		productType
		publishedAt
		requiresSellingPlan
		tags
		title
		updatedAt
		vendor

		options(first: ${defaults.page_size}) {
			name
			values
		}

		featuredImage {
			id
		}

		collections(first: ${defaults.page_size}) {
			${edges(gql `
				id
			`)}
		}

		images(first: ${defaults.page_size}) {
			${edges(image(image_format))}
		}

		${variants()}
	`;
}

function make_request_for_single_product({ id, image_format }) {
    return {
        query: gql `
			query FetchProduct($id: ID!) {
				product(id: $id) {
					${product({ image_format })}
				}
			}
		`,
        variables: {
            id,
        },
    };
}

function make_request_for_products({ query, after, image_format, page_size, sort, reverse, }) {
    return {
        query: gql `
			query FetchProducts(
				$first: Int!,
				$after: String,
				$sort: ProductSortKeys,
				$reverse: Boolean,
				$query: String,
				) {
				products(
					first: $first,
					after: $after,
					sortKey: $sort,
					reverse: $reverse,
					query: $query,
					) {
					${paginated(product({ image_format }))}
				}
			}
		`,
        variables: {
            query,
            after,
            first: page_size,
            sort,
            reverse,
        },
    };
}

function make_request_for_specific_products({ ids, image_format }) {
    return {
        query: gql `
			query FetchProducts($ids: [ID!]!) {
				products: nodes(ids: $ids) {
					... on Product {
						${product({ image_format })}
					}
				}
			}
		`,
        variables: {
            ids,
        },
    };
}

function make_request_for_collections({ after, image_format, page_size, }) {
    return {
        query: gql `
			query FetchCollections($first: Int!, $after: String) {
				collections(first: $first, after: $after) {
					${paginated(gql `

						description
						descriptionHtml
						handle
						id
						title
						updatedAt
						onlineStoreUrl

						image {
							${image(image_format)}
						}

					`)}
				}
			}
		`,
        variables: {
            after,
            first: page_size,
        },
    };
}

function make_request_for_checkout_create({ line_items, }) {
    return {
        query: gql `
			mutation CreateCheckout($input: CheckoutCreateInput!) {
				checkoutCreate(input: $input) {
					checkoutUserErrors {
						code
						field
						message
					}
					checkout {
						id
						webUrl
					}
				}
			}
		`,
        variables: {
            input: {
                lineItems: (line_items
                    .filter(quantity_is_greater_than_zero)
                    .map(i => ({
                    variantId: i.variant_id,
                    quantity: i.quantity
                })))
            },
        },
    };
}
function quantity_is_greater_than_zero(item) {
    return item.quantity > 0;
}

const backslash = "\\";
const characters_to_escape_in_queries = "\\:()\"\'";
function escape_query_text(text) {
    for (const character of characters_to_escape_in_queries)
        text = text.replace(character, backslash + character);
    return text;
}

function querytext(strings, ...values) {
    return Array.from(strings).reduce((previous, current, index) => {
        var _a;
        return previous +
            current +
            escape_query_text((_a = values[index]) !== null && _a !== void 0 ? _a : "");
    }, "");
}

function convert_product_query_spec_to_string({ tags = [], terms = [], } = {}) {
    const segments = [];
    if (tags.length)
        segments.push(tags
            .map(tag => querytext `(tag:${tag})`)
            .join(" AND "));
    if (terms.length)
        segments.push(terms
            .map(term => querytext `(title:*${term}* OR tag:*${term}*)`)
            .join(" AND "));
    return segments.length
        ? segments
            .map(segment => `(${segment})`)
            .join(" AND ")
        : undefined;
}

function make_request_for_products_in_collection({ after, page_size, image_format, collection_id, filters, }) {
    return {
        query: gql `
			query FetchProductsInCollection(
					$collection_id: ID!,
					$first: Int!,
					$after: String,
					$filters: [ProductFilter!],
				) {
				collection(id: $collection_id) {
					products(first: $first, after: $after, filters: $filters) {
						${paginated(product({ image_format }))}
					}
				}
			}
		`,
        variables: {
            collection_id,
            first: page_size,
            after,
            filters,
        },
    };
}

function make_request_for_product_recommendations({ intent, product_id, image_format, }) {
    return {
        query: gql `
			query FetchProductRecommendations($product_id: ID!, $intent: ProductRecommendationIntent) {
				productRecommendations(productId: $product_id, intent: $intent) {
					${product({ image_format })}
				}
			}
		`,
        variables: {
            intent,
            product_id,
        },
    };
}

class Shopify {
    static setup(settings) {
        return new this({ remote: new Remote(settings) });
    }
    constructor(o) {
        this.remote = o.remote;
    }
    async shop() {
        return this.remote.request(make_request_for_shop());
    }
    async product(o) {
        var _a;
        const { product } = await this.remote.request(make_request_for_single_product({
            id: o.id,
            image_format: (_a = o.image_format) !== null && _a !== void 0 ? _a : defaults.image_format,
        }));
        if (!product)
            throw new ShopifyNotFoundError(`product ${o.id}`);
        return product;
    }
    async *products(o = {}) {
        yield* paginate(async (after) => {
            var _a, _b, _c;
            return (await this.remote.request(make_request_for_products({
                after,
                page_size: (_a = o.page_size) !== null && _a !== void 0 ? _a : defaults.page_size,
                image_format: (_b = o.image_format) !== null && _b !== void 0 ? _b : defaults.image_format,
                query: convert_product_query_spec_to_string(o.query),
                sort: (_c = o.sort) !== null && _c !== void 0 ? _c : "BEST_SELLING",
                reverse: o.reverse,
            }))).products;
        });
    }
    async *collections(o = {}) {
        yield* paginate(async (after) => {
            var _a, _b;
            return (await this.remote.request(make_request_for_collections({
                after,
                page_size: (_a = o.page_size) !== null && _a !== void 0 ? _a : defaults.page_size,
                image_format: (_b = o.image_format) !== null && _b !== void 0 ? _b : defaults.image_format,
            }))).collections;
        });
    }
    async *tags(o = {}) {
        var _a;
        const result = await this.remote.request(make_request_for_tags({ page_size: (_a = o.page_size) !== null && _a !== void 0 ? _a : defaults.page_size }));
        const tags = result.productTags.edges.map(e => e.node);
        const more = false;
        yield [tags, more];
    }
    async *products_in_collection(o) {
        yield* paginate(async (after) => {
            var _a, _b, _c, _d;
            return (_d = (await this.remote.request(make_request_for_products_in_collection({
                after,
                collection_id: o.collection_id,
                page_size: (_a = o.page_size) !== null && _a !== void 0 ? _a : defaults.page_size,
                image_format: (_b = o.image_format) !== null && _b !== void 0 ? _b : defaults.image_format,
                filters: (_c = o.filters) !== null && _c !== void 0 ? _c : [],
            }))).collection) === null || _d === void 0 ? void 0 : _d.products;
        });
    }
    async product_recommendations(o) {
        var _a;
        return (await this.remote.request(make_request_for_product_recommendations({
            intent: o.intent,
            product_id: o.product_id,
            image_format: (_a = o.image_format) !== null && _a !== void 0 ? _a : defaults.image_format,
        }))).productRecommendations;
    }
    async specific_products(o) {
        var _a;
        return (await this.remote
            .request(make_request_for_specific_products({
            ids: o.ids,
            image_format: (_a = o.image_format) !== null && _a !== void 0 ? _a : defaults.image_format,
        }))).products;
    }
    async checkout(o) {
        const raw = await this.remote.request(make_request_for_checkout_create({
            line_items: o.line_items,
        }));
        if (!(raw === null || raw === void 0 ? void 0 : raw.checkoutCreate))
            throw new ShopifyNotFoundError(`Failed to create checkout`);
        const { checkout, checkoutUserErrors } = raw.checkoutCreate;
        if (checkoutUserErrors.length > 0)
            throw new ShopifyCheckoutError(checkoutUserErrors);
        return checkout;
    }
    async everything() {
        return concurrent({
            shop: this.shop(),
            tags: Shopify.all(this.tags()),
            products: Shopify.all(this.products()),
            collections: Shopify.all(this.collections()),
        });
    }
}
Shopify.all = all;
Shopify.first = first;

const slate = new Slate();

function translator(t) {
    return t;
}

function expand_id(pre, num) {
    return `gid://shopify/${pre}/${num}`;
}
function expander(pre) {
    return (n) => expand_id(pre, n);
}
const utransform = {
    label: (label) => label.toLowerCase(),
    id: {
        shorten: (id) => id.split("/").at(-1),
        expand: {
            collection: expander("Collection"),
            product: expander("Product"),
        },
    },
};

const translators = (home) => ({
    home: translator({
        hashify: () => "/",
        routify: () => ({ zone: "home", area: home }),
    }),
    products: translator({
        hashify: () => "/products",
        routify: () => ({ zone: "products" }),
    }),
    collections: translator({
        hashify: () => "/collections",
        routify: () => ({ zone: "collections" }),
    }),
    search: translator({
        hashify: ({ terms, tags }) => {
            const e = (t) => t.map(encodeURIComponent).join(":");
            const query = tags.length > 0
                ? e(terms) + "::" + e(tags)
                : e(terms);
            return `/search/${query}`;
        },
        routify: hashparts => {
            const [raw] = hashparts;
            const splitty = (s) => s.split(":").filter(t => t.length);
            if (raw.includes("::")) {
                const [rawterms, rawtags] = raw.split("::");
                const tags = splitty(rawtags);
                const terms = splitty(rawterms);
                return { zone: "search", terms, tags };
            }
            else
                return { zone: "search", terms: splitty(raw), tags: [] };
        },
    }),
    collection: translator({
        hashify: ({ label, id }) => `/collection/${label}/${utransform.id.shorten(id)}`,
        routify: ([label, id]) => ({
            zone: "collection",
            label,
            id: utransform.id.expand.collection(id),
        }),
    }),
    product: translator({
        hashify: ({ label, id }) => `/product/${label}/${utransform.id.shorten(id)}`,
        routify: ([label, id]) => ({
            zone: "product",
            label,
            id: utransform.id.expand.product(id),
        }),
    }),
    not_found: translator({
        hashify: () => "/",
        routify: () => ({ zone: "not_found" }),
    }),
});

// import {decode_from_hash} from "./decode_from_hash.js"
function parse_hash_parts(prefix, hash) {
    if (hash && hash[0] === "#")
        hash = hash.slice(1);
    if (prefix && hash && hash.startsWith(prefix))
        hash = hash.slice(prefix.length);
    return hash.includes("/")
        ? hash.split("/").slice(1)
        : [hash];
    // return parts.map(part => decode_from_hash(part))
}

var __classPrivateFieldSet$6 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$7 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Translation_instances, _Translation_prefix, _Translation_home, _Translation_get;
class Translation {
    constructor(home, prefix) {
        _Translation_instances.add(this);
        _Translation_prefix.set(this, void 0);
        _Translation_home.set(this, void 0);
        __classPrivateFieldSet$6(this, _Translation_prefix, prefix, "f");
        __classPrivateFieldSet$6(this, _Translation_home, home, "f");
    }
    routify(hash) {
        const [zone, ...hashparts] = parse_hash_parts(__classPrivateFieldGet$7(this, _Translation_prefix, "f"), hash);
        return __classPrivateFieldGet$7(this, _Translation_instances, "m", _Translation_get).call(this, zone).routify(hashparts);
    }
    hashify(route) {
        return __classPrivateFieldGet$7(this, _Translation_prefix, "f") + __classPrivateFieldGet$7(this, _Translation_instances, "m", _Translation_get).call(this, route.zone).hashify(route);
    }
}
_Translation_prefix = new WeakMap(), _Translation_home = new WeakMap(), _Translation_instances = new WeakSet(), _Translation_get = function _Translation_get(zone) {
    const t = translators(__classPrivateFieldGet$7(this, _Translation_home, "f"));
    if (zone === "")
        zone = "home";
    if (!(zone in t))
        zone = "not_found";
    return t[zone];
};

var __classPrivateFieldSet$5 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$6 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Router_instances, _Router_set_hash, _Router_translation, _Router_route, _Router_home, _Router_routefor;
class Router {
    constructor({ home, prefix = "", set_hash }) {
        _Router_instances.add(this);
        _Router_set_hash.set(this, void 0);
        _Router_translation.set(this, void 0);
        _Router_route.set(this, void 0);
        _Router_home.set(this, void 0);
        this.on_route_change = pub();
        this.hashchange = (event) => {
            const { hash } = new URL(event.newURL);
            this.apply_hash(hash);
        };
        this.routes = {
            home: () => __classPrivateFieldGet$6(this, _Router_instances, "m", _Router_routefor).call(this, { zone: "home", area: __classPrivateFieldGet$6(this, _Router_home, "f") }),
            collections: () => __classPrivateFieldGet$6(this, _Router_instances, "m", _Router_routefor).call(this, { zone: "collections" }),
            products: () => __classPrivateFieldGet$6(this, _Router_instances, "m", _Router_routefor).call(this, { zone: "products" }),
            search: (terms, tags) => __classPrivateFieldGet$6(this, _Router_instances, "m", _Router_routefor).call(this, { zone: "search", terms, tags }),
            collection: ({ id, handle: label }) => __classPrivateFieldGet$6(this, _Router_instances, "m", _Router_routefor).call(this, { zone: "collection", id, label }),
            product: ({ id, handle: label }) => __classPrivateFieldGet$6(this, _Router_instances, "m", _Router_routefor).call(this, { zone: "product", id, label }),
        };
        __classPrivateFieldSet$5(this, _Router_home, home, "f");
        __classPrivateFieldSet$5(this, _Router_set_hash, set_hash, "f");
        __classPrivateFieldSet$5(this, _Router_route, { zone: "home", area: home }, "f");
        __classPrivateFieldSet$5(this, _Router_translation, new Translation(home, prefix), "f");
    }
    static setup(home, prefix = "") {
        const router = new Router({
            home,
            prefix,
            set_hash: hash => location.hash = hash,
        });
        router.apply_hash(location.hash);
        addEventListener("hashchange", router.hashchange);
        return router;
    }
    get route() {
        return __classPrivateFieldGet$6(this, _Router_route, "f");
    }
    set route(r) {
        const hash = __classPrivateFieldGet$6(this, _Router_translation, "f").hashify(r);
        __classPrivateFieldGet$6(this, _Router_set_hash, "f").call(this, hash);
    }
    apply_hash(hash) {
        const route = __classPrivateFieldGet$6(this, _Router_translation, "f").routify(hash);
        __classPrivateFieldSet$5(this, _Router_route, route, "f");
        this.on_route_change.publish(route);
    }
    get search_terms() {
        const route = __classPrivateFieldGet$6(this, _Router_route, "f");
        return (route && route.zone === "search")
            ? route.terms
            : [];
    }
    get search_tags() {
        const route = __classPrivateFieldGet$6(this, _Router_route, "f");
        return (route && route.zone === "search")
            ? route.tags
            : [];
    }
}
_Router_set_hash = new WeakMap(), _Router_translation = new WeakMap(), _Router_route = new WeakMap(), _Router_home = new WeakMap(), _Router_instances = new WeakSet(), _Router_routefor = function _Router_routefor(route) {
    const hash = __classPrivateFieldGet$6(this, _Router_translation, "f").hashify(route);
    return {
        url: "#" + hash,
        go: () => __classPrivateFieldGet$6(this, _Router_set_hash, "f").call(this, hash),
    };
};

var __classPrivateFieldSet$4 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$5 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Cart_instances, _Cart_shopify, _Cart_store, _Cart_state, _Cart_flatstate, _Cart_get_item, _Cart_get_product, _Cart_fetch_products;
class Cart {
    constructor(shopify, store) {
        _Cart_instances.add(this);
        _Cart_shopify.set(this, void 0);
        _Cart_store.set(this, void 0);
        _Cart_state.set(this, void 0);
        _Cart_flatstate.set(this, (x) => flat.state(x));
        __classPrivateFieldSet$4(this, _Cart_shopify, shopify, "f");
        __classPrivateFieldSet$4(this, _Cart_store, store, "f");
        __classPrivateFieldSet$4(this, _Cart_state, flat.state({
            items: [],
            products: [],
        }), "f");
        this.state = Flat.readonly(__classPrivateFieldGet$5(this, _Cart_state, "f"));
    }
    save() {
        const { items } = __classPrivateFieldGet$5(this, _Cart_state, "f");
        __classPrivateFieldGet$5(this, _Cart_store, "f").save({ items });
    }
    async load() {
        const pack = __classPrivateFieldGet$5(this, _Cart_store, "f").load();
        const promise = __classPrivateFieldGet$5(this, _Cart_instances, "m", _Cart_fetch_products).call(this, pack.items);
        __classPrivateFieldGet$5(this, _Cart_state, "f").items = pack.items.map(__classPrivateFieldGet$5(this, _Cart_flatstate, "f"));
        await promise;
    }
    get units() {
        return __classPrivateFieldGet$5(this, _Cart_state, "f").items
            .map(item => ({ item, product: __classPrivateFieldGet$5(this, _Cart_instances, "m", _Cart_get_product).call(this, item.product_id) }))
            .filter(data => !!data.product && Op.is.ready(data.product.op))
            .map(data => {
            const product = Op.payload(data.product.op);
            const variant = product === null || product === void 0 ? void 0 : product.variants.edges.map(e => e.node).find(v => v.id === data.item.variant_id);
            return (!!product && !!variant && variant.availableForSale)
                ? {
                    product,
                    variant,
                    product_id: data.item.product_id,
                    variant_id: data.item.variant_id,
                    quantity: data.item.quantity,
                }
                : undefined;
        })
            .filter(u => !!u);
    }
    add(variant_id, product) {
        // add item
        __classPrivateFieldGet$5(this, _Cart_state, "f").items = [
            __classPrivateFieldGet$5(this, _Cart_flatstate, "f").call(this, {
                product_id: product.id,
                variant_id,
                quantity: 1,
            }),
            ...__classPrivateFieldGet$5(this, _Cart_state, "f").items.filter(i => i.variant_id !== variant_id),
        ];
        // add product in ready state
        __classPrivateFieldGet$5(this, _Cart_state, "f").products = [
            __classPrivateFieldGet$5(this, _Cart_flatstate, "f").call(this, {
                product_id: product.id,
                op: Op.ready(product),
            }),
            ...__classPrivateFieldGet$5(this, _Cart_state, "f").products.filter(p => p.product_id !== product.id),
        ];
        this.save();
    }
    remove(variant_id) {
        __classPrivateFieldGet$5(this, _Cart_state, "f").items = __classPrivateFieldGet$5(this, _Cart_state, "f").items
            .filter(i => i.variant_id !== variant_id);
        this.save();
    }
    set_quantity(variant_id, quantity) {
        const item = __classPrivateFieldGet$5(this, _Cart_instances, "m", _Cart_get_item).call(this, variant_id);
        item.quantity = quantity;
        this.save();
    }
    clear() {
        __classPrivateFieldGet$5(this, _Cart_state, "f").items = [];
        this.save();
    }
}
_Cart_shopify = new WeakMap(), _Cart_store = new WeakMap(), _Cart_state = new WeakMap(), _Cart_flatstate = new WeakMap(), _Cart_instances = new WeakSet(), _Cart_get_item = function _Cart_get_item(variant_id) {
    return __classPrivateFieldGet$5(this, _Cart_state, "f").items.find(i => i.variant_id === variant_id);
}, _Cart_get_product = function _Cart_get_product(product_id) {
    return __classPrivateFieldGet$5(this, _Cart_state, "f").products.find(i => i.product_id === product_id);
}, _Cart_fetch_products = async function _Cart_fetch_products(items) {
    var _a;
    const new_product_ids = items
        .filter(i => !__classPrivateFieldGet$5(this, _Cart_instances, "m", _Cart_get_product).call(this, i.product_id))
        .map(i => i.product_id);
    const new_caches = new_product_ids
        .map(product_id => ({ product_id, op: Op.loading() }))
        .map(__classPrivateFieldGet$5(this, _Cart_flatstate, "f"));
    __classPrivateFieldGet$5(this, _Cart_state, "f").products = [
        ...__classPrivateFieldGet$5(this, _Cart_state, "f").products,
        ...new_caches
    ];
    if (new_product_ids.length > 0) {
        try {
            const products = (_a = (await __classPrivateFieldGet$5(this, _Cart_shopify, "f")
                .specific_products({ ids: new_product_ids }))) !== null && _a !== void 0 ? _a : [];
            for (const cache of new_caches) {
                const product = products.find(p => (p === null || p === void 0 ? void 0 : p.id) === cache.product_id);
                cache.op = product
                    ? Op.ready(product)
                    : Op.error("error retrieving product");
            }
        }
        catch (error) {
            console.error("a cart product could not be loaded,", error);
            this.clear();
        }
    }
};

var __classPrivateFieldGet$4 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$3 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _IdPuller_counter;
class IdPuller {
    constructor() {
        _IdPuller_counter.set(this, 0);
    }
    pull() {
        var _a, _b;
        return __classPrivateFieldSet$3(this, _IdPuller_counter, (_b = __classPrivateFieldGet$4(this, _IdPuller_counter, "f"), _a = _b++, _b), "f"), _a;
    }
}
_IdPuller_counter = new WeakMap();

var __classPrivateFieldGet$3 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Modal_id;
class Modal {
    constructor() {
        _Modal_id.set(this, new IdPuller());
        this.on = {
            open: pub(),
        };
    }
    open(modal) {
        this.on.open.publish({
            modal,
            id: __classPrivateFieldGet$3(this, _Modal_id, "f").pull().toString(),
        });
    }
}
_Modal_id = new WeakMap();

function init_state(router) {
    return flat.state({
        route: router.route,
        tags: [],
        collections: [],
        situation_op: Op.loading(),
        cart_open: false,
    });
}

var __classPrivateFieldSet$2 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$2 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Context_state;
class Context extends Context$1 {
    constructor(shopify, router, theme, cart_store) {
        super();
        this.shopify = shopify;
        this.router = router;
        this.theme = theme;
        _Context_state.set(this, void 0);
        this.modal = new Modal();
        this.set_route = (route) => __classPrivateFieldGet$2(this, _Context_state, "f").route = route;
        this.set_tags = (tags) => __classPrivateFieldGet$2(this, _Context_state, "f").tags = tags;
        this.set_collections = (collections) => __classPrivateFieldGet$2(this, _Context_state, "f").collections = collections;
        this.set_situation_op = (op) => __classPrivateFieldGet$2(this, _Context_state, "f").situation_op = op;
        this.toggle_cart_open = (open = !__classPrivateFieldGet$2(this, _Context_state, "f").cart_open) => {
            __classPrivateFieldGet$2(this, _Context_state, "f").cart_open = open;
        };
        __classPrivateFieldSet$2(this, _Context_state, init_state(router), "f");
        this.state = Flat.readonly(__classPrivateFieldGet$2(this, _Context_state, "f"));
        this.cart = new Cart(this.shopify, cart_store);
    }
}
_Context_state = new WeakMap();

function* compile(expressions) {
    function recurse(expression, previousSelector) {
        let css = [];
        const selector = expression[0];
        // This is an at-rule, not a regular selector.
        if (selector.startsWith("@")) {
            const directive = expression[0];
            const children = expression[1];
            css.push(`${stripAwayComments(directive)}`);
            for (const child of children)
                css = [...css, ...recurse(child, undefined)];
            css.push(`}`);
        }
        // This is a regular selector.
        else {
            const rules = expression[1];
            const children = expression[2];
            const compoundSelector = previousSelector
                ? handleParentReference(`${previousSelector} ${selector}`)
                : selector;
            const ruleEntries = Object.entries(rules);
            if (ruleEntries.length > 0) {
                const rulesString = ruleEntries
                    .map(([ruleName, ruleValue]) => `\t${ruleName}: ${stripAwayComments(ruleValue)};`)
                    .join("\n");
                css.push(`${stripAwayComments(compoundSelector)} {\n${rulesString}\n}`);
            }
            for (const child of children)
                css = [...css, ...recurse(child, compoundSelector)];
        }
        return css;
    }
    yield "\n";
    for (const expression of expressions)
        yield "\n" + recurse(expression, undefined).join("\n");
    yield "\n";
}
function stripAwayComments(text) {
    return text.replaceAll(/(\s*)(\/\/.*)$/gm, "");
}
function handleParentReference(groupedSelector) {
    return groupedSelector.replaceAll(/(\s+)*(\^|&)/gm, "");
}

var Token;
(function (Token) {
    (function (Type) {
        Type[Type["AtRule"] = 0] = "AtRule";
        Type[Type["Open"] = 1] = "Open";
        Type[Type["Close"] = 2] = "Close";
        Type[Type["RuleName"] = 3] = "RuleName";
        Type[Type["RuleValue"] = 4] = "RuleValue";
        Type[Type["SlashSlashComment"] = 5] = "SlashSlashComment";
    })(Token.Type || (Token.Type = {}));
})(Token || (Token = {}));

class CamelCssError extends Error {
    constructor() {
        super(...arguments);
        this.name = this.constructor.name;
    }
}
//
// untracable errors
//
class CamelCssMissingClosingBraceError extends CamelCssError {
    constructor(missingCloses) {
        const message = missingCloses > 1
            ? `missing ${missingCloses} closing braces "}"`
            : `missing ${missingCloses} closing brace "}"`;
        super(message);
    }
}
//
// traceable errors
//
class CamelCssTraceableError extends CamelCssError {
    constructor(trace, message) {
        super(`(${trace.cursor.line}:${trace.cursor.column}) ${message}`);
        this.trace = trace;
    }
}
class CamelCssMissingSelectorOrAtRuleError extends CamelCssTraceableError {
    constructor(trace) {
        super(trace, `expression is missing selector (or at-rule)`);
    }
}
class CamelCssExcessClosingBraceError extends CamelCssTraceableError {
    constructor(trace) {
        super(trace, `unwanted closing brace "}"`);
    }
}
class CamelCssRuleNamePlacementError extends CamelCssTraceableError {
    constructor(trace, ruleName) {
        super(trace, `invalid place for rule name "${ruleName}"`);
    }
}
class CamelCssRuleValuePlacementError extends CamelCssTraceableError {
    constructor(trace, ruleValue) {
        super(trace, `invalid place for rule value "${ruleValue}"`);
    }
}
const setupTracedErrors = (trace) => ({
    error: (message) => new CamelCssTraceableError(trace, message),
    missingSelectorOrAtRule: () => new CamelCssMissingSelectorOrAtRuleError(trace),
    excessClosingBrace: () => new CamelCssExcessClosingBraceError(trace),
    ruleNamePlacement: (ruleName) => new CamelCssRuleNamePlacementError(trace, ruleName),
    ruleValuePlacement: (ruleValue) => new CamelCssRuleValuePlacementError(trace, ruleValue),
});

function* parse(tokens) {
    let frame;
    const stack = [];
    for (const token of tokens) {
        const error = setupTracedErrors(token.trace);
        switch (token.type) {
            case Token.Type.Open:
            case Token.Type.AtRule:
                {
                    frame = {
                        selector: (token.type === Token.Type.AtRule)
                            ? token.directive
                            : token.selector.replaceAll(/\s+/gm, " "),
                        ruleName: undefined,
                        rules: {},
                        childFrames: [],
                    };
                    stack.push(frame);
                }
                break;
            case Token.Type.RuleName:
                {
                    if (!frame)
                        throw error.ruleNamePlacement(token.name);
                    frame.ruleName = token.name;
                }
                break;
            case Token.Type.RuleValue:
                {
                    if (!frame || !frame.ruleName)
                        throw error.ruleValuePlacement(token.value);
                    frame.rules[frame.ruleName] = token.value;
                    frame.ruleName = undefined;
                }
                break;
            case Token.Type.Close:
                {
                    const completedFrame = stack.pop();
                    const parentFrame = stack.length > 0
                        ? stack[stack.length - 1]
                        : undefined;
                    frame = parentFrame;
                    if (!completedFrame)
                        throw error.excessClosingBrace();
                    if (!completedFrame.selector)
                        throw error.missingSelectorOrAtRule();
                    if (parentFrame)
                        parentFrame.childFrames.push(completedFrame);
                    else {
                        function recursiveFrameToExpression(frame) {
                            if (frame.selector.startsWith("@")) {
                                return [
                                    frame.selector,
                                    frame.childFrames.map(recursiveFrameToExpression),
                                ];
                            }
                            else {
                                return [
                                    frame.selector,
                                    frame.rules,
                                    frame.childFrames.map(recursiveFrameToExpression),
                                ];
                            }
                        }
                        yield recursiveFrameToExpression(completedFrame);
                    }
                }
                break;
        }
    }
    if (stack.length > 0)
        throw new CamelCssMissingClosingBraceError(stack.length);
}

function runTokenRegex({ source, regex, index, setIndex, }) {
    regex.lastIndex = index;
    const match = regex.exec(source.code);
    if (match)
        setIndex(regex.lastIndex);
    return match;
}

const leadingWhitespaceRegex = /(\s*)/my;
function runLeadingWhitespaceRegex({ source, index, setIndex }) {
    leadingWhitespaceRegex.lastIndex = index;
    const match = leadingWhitespaceRegex.exec(source.code);
    if (match)
        setIndex(leadingWhitespaceRegex.lastIndex);
    const [, whitespace = ""] = match ?? [];
    return whitespace;
}

function updateCursor(part, cursor, newIndex) {
    const linebreaks = (/\n/g.exec(part) ?? []).length;
    const line = cursor.line + linebreaks;
    let column = 0;
    if (linebreaks > 0) {
        const [, lastLine] = /\n(.*)$/.exec(part) ?? [];
        column = 1 + lastLine.length;
    }
    else
        column = cursor.column + (newIndex - cursor.index);
    return {
        line,
        column,
        index: newIndex,
    };
}

function defineMakeTraceFunction({ index, cursor, leadingWhitespace }) {
    return (valueLength) => {
        const subcursor = updateCursor(leadingWhitespace, cursor, cursor.index + leadingWhitespace.length);
        return {
            cursor: subcursor,
            length: valueLength ?? (index - subcursor.index),
        };
    };
}

function makeLexer(regex, readToken) {
    return ((source, cursor) => {
        let index = cursor.index;
        const setIndex = (newIndex) => index = newIndex;
        const leadingWhitespace = runLeadingWhitespaceRegex({
            source, index, setIndex,
        });
        const match = runTokenRegex({
            source, regex, index, setIndex,
        });
        return match
            ? {
                newIndex: index,
                token: readToken(match, defineMakeTraceFunction({ index, cursor, leadingWhitespace }))
            }
            : undefined;
    });
}

const lexers = {
    slashSlashComment: makeLexer(/(\/\/.*)$/my, (match, makeTrace) => {
        const [, value] = match;
        const trimmedValue = value.trim();
        return {
            type: Token.Type.SlashSlashComment,
            trace: makeTrace(trimmedValue.length),
            value: trimmedValue,
        };
    }),
    atRule: makeLexer(/(@(?:[^;{]+[;]|[^{]+{))/my, (match, makeTrace) => {
        const [, directive] = match;
        const trimmedDirective = directive.trim();
        return {
            type: Token.Type.AtRule,
            trace: makeTrace(trimmedDirective.length),
            directive: trimmedDirective,
        };
    }),
    open: makeLexer(/([^{};]*){/my, (match, makeTrace) => {
        const [, selector] = match;
        const trimmedSelector = selector.trim();
        return {
            type: Token.Type.Open,
            trace: makeTrace(trimmedSelector.length),
            selector: trimmedSelector,
        };
    }),
    close: makeLexer(/}/my, (match, makeTrace) => {
        return {
            type: Token.Type.Close,
            trace: makeTrace(1),
        };
    }),
    ruleName: makeLexer(/([\S]+):/my, (match, makeTrace) => {
        const [, name] = match;
        const trimmedName = name.trim();
        return {
            type: Token.Type.RuleName,
            trace: makeTrace(trimmedName.length),
            name: trimmedName,
        };
    }),
    ruleValue: makeLexer(/([^;}]+)(;|(?=}))/my, (match, makeTrace) => {
        const [, value] = match;
        const trimmedValue = value.trim();
        return {
            type: Token.Type.RuleValue,
            trace: makeTrace(trimmedValue.length),
            value: trimmedValue,
        };
    }),
};

function* tokenize(code) {
    const source = { code };
    let done = false;
    let cursor = {
        index: 0,
        line: 1,
        column: 1,
    };
    while (!done) {
        let token;
        for (const lexer of Object.values(lexers)) {
            let result = lexer(source, cursor);
            if (result) {
                token = result.token;
                cursor = updateCursor(source.code.slice(cursor.index, result.newIndex), cursor, result.newIndex);
                break;
            }
        }
        if (token)
            yield token;
        else
            done = true;
    }
}

function camelCss(input) {
    const tokens = tokenize(input);
    const expressions = parse(tokens);
    return [...compile(expressions)].join("");
}

function css(strings, ...values) {
    const input = Array.from(strings).reduce((previous, current, index) => previous + current + (values[index] ?? ""), "");
    const output = camelCss(input);
    return r$4(output);
}

const ev = (Event) => ({
    target: (target) => ({
        dispatch(detail, options) {
            target.dispatchEvent(new Event(Event.type, { ...options, detail }));
        },
        listen(listener, options) {
            target.addEventListener(Event.type, listener, options);
            return () => target
                .removeEventListener(Event.type, listener, options);
        },
    })
});

const defaultDispatchOptions = {
    bubbles: true,
    composed: true,
    cancelable: true,
};

var _a$1;
class MagicEventBase extends CustomEvent {
    constructor(name, options) {
        super(name, { ...defaultDispatchOptions, ...options });
    }
}
_a$1 = MagicEventBase;
MagicEventBase.target = ev(_a$1).target;

(undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
(undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};

(undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
(undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};

(undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
(undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};

var __classPrivateFieldGet$1 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$1 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _TemplateSlots_instances, _a, _TemplateSlots_parent, _TemplateSlots_templates, _TemplateSlots_parentObserver, _TemplateSlots_templateObservers, _TemplateSlots_onChange, _TemplateSlots_refresh;
class TemplateSlots {
    constructor(parent, onChange = () => { }) {
        _TemplateSlots_instances.add(this);
        _TemplateSlots_parent.set(this, void 0);
        _TemplateSlots_templates.set(this, new Map());
        _TemplateSlots_parentObserver.set(this, void 0);
        _TemplateSlots_templateObservers.set(this, new Set);
        _TemplateSlots_onChange.set(this, () => { });
        __classPrivateFieldSet$1(this, _TemplateSlots_parent, parent, "f");
        __classPrivateFieldSet$1(this, _TemplateSlots_onChange, onChange, "f");
        __classPrivateFieldSet$1(this, _TemplateSlots_parentObserver, new MutationObserver(() => __classPrivateFieldGet$1(this, _TemplateSlots_instances, "m", _TemplateSlots_refresh).call(this)), "f");
        __classPrivateFieldGet$1(this, _TemplateSlots_parentObserver, "f").observe(parent, _a.parentObservationOptions);
        __classPrivateFieldGet$1(this, _TemplateSlots_instances, "m", _TemplateSlots_refresh).call(this);
    }
    get(name) {
        const selector = name
            ? `:scope > template[slot="${name}"]`
            : `:scope > template:not([slot])`;
        const template = __classPrivateFieldGet$1(this, _TemplateSlots_parent, "f")
            .querySelector(selector);
        return template?.content.cloneNode(true);
    }
}
_a = TemplateSlots, _TemplateSlots_parent = new WeakMap(), _TemplateSlots_templates = new WeakMap(), _TemplateSlots_parentObserver = new WeakMap(), _TemplateSlots_templateObservers = new WeakMap(), _TemplateSlots_onChange = new WeakMap(), _TemplateSlots_instances = new WeakSet(), _TemplateSlots_refresh = function _TemplateSlots_refresh() {
    for (const observer of __classPrivateFieldGet$1(this, _TemplateSlots_templateObservers, "f"))
        observer.disconnect();
    __classPrivateFieldGet$1(this, _TemplateSlots_templates, "f").clear();
    __classPrivateFieldGet$1(this, _TemplateSlots_templateObservers, "f").clear();
    const templates = Array.from(__classPrivateFieldGet$1(this, _TemplateSlots_parent, "f").querySelectorAll(":scope > template"));
    for (const template of templates) {
        const name = template.getAttribute("slot") ?? undefined;
        __classPrivateFieldGet$1(this, _TemplateSlots_templates, "f").set(name, template);
        const deepObserver = new MutationObserver(__classPrivateFieldGet$1(this, _TemplateSlots_onChange, "f"));
        const attributeObserver = new MutationObserver(() => {
            __classPrivateFieldGet$1(this, _TemplateSlots_instances, "m", _TemplateSlots_refresh).call(this);
            __classPrivateFieldGet$1(this, _TemplateSlots_onChange, "f").call(this);
        });
        deepObserver.observe(template.content, _a.templateDeepObserverationOptions);
        attributeObserver.observe(template, _a.templateAttributeObserverationOptions);
        __classPrivateFieldGet$1(this, _TemplateSlots_templateObservers, "f").add(deepObserver);
    }
};
TemplateSlots.parentObservationOptions = {
    childList: true,
};
TemplateSlots.templateDeepObserverationOptions = {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true,
};
TemplateSlots.templateAttributeObserverationOptions = {
    attributes: true,
};

const style$3 = css `

:host {
	display: flex;
	gap: 1em;
}

a {
	color: inherit;
	text-decoration: none;

	&[data-marked] {
		text-decoration: underline;
	}
}

`;

const SheepNav = slate.shadow_component({ styles: style$3 }, use => {
    const { route } = use.context.state;
    const { routes } = use.context.router;
    function get_areas() {
        return {
            collections: {
                url: routes.collections().url,
                marked: (route.zone === "collections" ||
                    (route.zone === "home" && route.area === "collections"))
            },
            products: {
                url: routes.products().url,
                marked: (route.zone === "products" ||
                    (route.zone === "home" && route.area === "products"))
            },
        };
    }
    const areas = get_areas();
    return html `
		<a
			href="${areas.collections.url}"
			?data-marked="${areas.collections.marked}">
			<slot name=collections>
				collections
			</slot>
		</a>

		<a
			href="${areas.products.url}"
			?data-marked="${areas.products.marked}">
			<slot name=products>
				all products
			</slot>
		</a>
	`;
});

const styles$9 = css `

:host {
	display: flex;
	flex-direction: column;
	--slash-color: var(--sheep-slash-color, #f008);
}

.sale {
	width: max-content;
	align-self: end;
	padding: 0.2em 0.4em;
	border-radius: 1em;
	background: #0808;
	text-transform: uppercase;
}

.coolstack {
	display: flex;
	flex-direction: row-reverse;
	flex-wrap: wrap;
	align-items: center;
	gap: 0.5em;
	flex: flex-wrap;
}

.pricetag {
	display: flex;
	align-items: center;
	gap: 0.1em;

	.symbol {
		font-size: 2em;
		align-self: center;
	}

	.big {
		font-size: 2.4em;
	}

	.stack {
		display: inline-flex;
		flex-direction: column;
		line-height: 1em;

		> .currency {
			opacity: 0.5;
			font-size: 0.75em;
		}
	}

	&.comparison {
		font-size: 0.7em;
		position: relative;
		width: max-content;

		& > * {
			opacity: 0.4;
		}

		& [part="slash"] {
			color: var(--slash-color);
			position: absolute;
			inset: 0;
			width: 100%;
			height: 100%;
			background: linear-gradient(to top left,
				transparent 0%,
				transparent calc(50% - 2px),
				currentColor calc(50% - 2px),
				currentColor calc(50% + 2px),
				transparent calc(50% + 2px),
				transparent 100%);
			pointer-events: none;
		}
	}
}

`;

function get_symbol_for_currency_code(currencyCode) {
    switch (currencyCode.toUpperCase()) {
        case "USD":
        case "CAD":
        case "AUD":
        case "NZD":
        case "HKD":
        case "SGD":
            return "$";
        case "EUR":
            return "€";
        case "GBP":
            return "£";
        case "JPY":
        case "CNY":
            return "¥";
        case "INR":
            return "₹";
        case "BRL":
            return "R$";
        case "ZAR":
            return "R";
        case "RUB":
            return "₽";
        case "KRW":
            return "₩";
        case "TRY":
            return "₺";
        default:
            return undefined;
    }
}

function parse_money({ price, compareAtPrice }) {
    return {
        value: parse_money_value(price),
        comparison: compareAtPrice
            ? parse_money_value(compareAtPrice)
            : undefined,
    };
}
function parse_money_value(price) {
    const { amount, currencyCode: currency } = price;
    const number = parseFloat(amount);
    const symbol = get_symbol_for_currency_code(currency);
    const [big, smallraw] = number
        .toFixed(2)
        .split(".")
        .map(part => parseInt(part).toLocaleString());
    const small = (smallraw !== null && smallraw !== void 0 ? smallraw : "0").padStart(2, "0");
    return { number, symbol, currency, big, small };
}

function render_sale_tag(price, comparison) {
    const fraction = (comparison.number - price.number) / comparison.number;
    const percent = Math.round(fraction * 100);
    return html `
		<span class=sale part=sale data-gpart=sale>
			${percent}% off
		</span>
	`;
}

function render_money_value({ symbol, currency, big, small }) {
    return html `
		${symbol
        ? html `<span class=symbol>${symbol}</span>`
        : undefined}
		<span class=big>${big}</span>
		<span class=stack>
			${small
        ? html `<span class=small>${small}</span>`
        : undefined}
			<span class=currency>${currency}</span>
		</span>
	`;
}

const Price = slate.shadow_view({
    styles: styles$9,
    name: "price",
}, _use => (variant) => {
    const { value, comparison } = parse_money(variant);
    return html `
		${comparison
        ? render_sale_tag(value, comparison)
        : undefined}

		<div class=coolstack>
			<div class="pricetag" ?data-sale=${!!comparison}>
				${render_money_value(value)}
			</div>

			${comparison
        ? html `
					<div class="pricetag comparison">
						${render_money_value(comparison)}
						<div part=slash></div>
					</div>
				`
        : undefined}
		</div>
	`;
});

const style$2 = css `

:host {
	display: flex;
	flex-direction: column;
	gap: 1em;
}

:host([hidden]) {
	display: none;
}

h2 {
	opacity: 0.4;
	text-transform: uppercase;
	text-align: center;
}

.listing {
	list-style: none;
	display: grid;
	grid-template-columns: auto auto 2fr auto;
	grid-auto-rows: auto;
	gap: 1em;
	align-items: center;

	> li {
		display: contents;

		> .thumb {
			grid-column: 1;
			> img {
				display: block;
				width: 3em;
				height: 5em;
				object-fit: cover;
				padding: 0.3rem;
				background: #fff4;
			}
		}

		> .quantity {
			grid-column: 2;
			> input {
				font-size: 1.5em;
				width: 3em;
				background: transparent;
				color: currentColor;
				border: 1px solid currentColor;
				border-radius: 0.5em;
				padding: 0.2em 0.5em;
			}
		}

		> .title {
			grid-column: 3;
		}

		> .price {
			grid-column: 4;
			justify-self: end;
		}

		> .remove {
			grid-column: 5;
			& button {
				display: flex;
				border: none;
				background: transparent;
				opacity: 0.4;
				cursor: pointer;
				color: currentColor;
				&:is(:hover, :focus) { opacity: 0.8; }
				&:active { opacity: 1; }
				& svg {
					width: 1.5rem;
					height: 1.5rem;
				}
			}
		}
	}
}

.subtotal {
	display: flex;
	justify-content: end;
	padding-right: 2.5rem;

	& .group {
		display: flex;
		flex-direction: column;
		width: max-content;
	}

	& hr {
		opacity: 0.3;
		display: block;
		border: none;
		width: 100%;
		height: 0.1em;
		margin: 1em auto;
		background: currentColor;
	}

	& .block {
		display: flex;
	}

	& .heading {
		opacity: 0.4;
		display: flex;
		align-items: end;
		padding-bottom: 0.5em;
		padding-right: 3em;
		text-transform: uppercase;
		font-weight: bold;
	}
}

.terms, .terms-checkbox {
	display: block;
	padding-right: 2.5rem;

	&:is(.terms) {
		margin-top: 2rem;
	}

	&:is(.terms-checkbox) {
		margin-top: 2rem;
		margin-left: auto;
		text-align: right;
	}
}

.terms-checkbox {
	& label {
		display: flex;
		align-items: center;
		gap: 0.5em;
	}
	& input {
		width: 1.5em;
		height: 1.5em;
	}
}

.actions {
	display: flex;
	flex-direction: row-reverse;
	gap: 1em;
	padding-top: 1em;
	padding-right: 2.5rem;
	align-items: center;
}

[part="checkout"]{
	font-size: 1.5em;

	&::part(button) {
		padding: 0.5em 1em;
	}
}

[part="clear-cart"] {
	font-size: 1em;

	&::part(button) {
		padding: 0.5em 1em;
		background: transparent;
	}
}

:host {
	container: layout / inline-size;
}

@container (width < 40em) {
	.listing {
		display: flex;
		grid: none;
		flex-direction: column;
		align-items: stretch;
		gap: 1em;

		> li {
			display: grid;
			grid:
				"thumb  title quantity"
				"remove price price   "
				/ auto  minmax(1em, 1fr)   auto;

			background: #fff4;
			padding: 0.5rem;
			box-shadow: 0.2em 0.3em 0.2em #0001;

			> .thumb { grid-area: thumb; }
			> .title { grid-area: title; }
			> .quantity { grid-area: quantity; }
			> .price { grid-area: price; }
			> .remove { grid-area: remove; }

			> .title { padding: 0 0.5rem; }

			> .remove {
				justify-self: center;
				align-self: end;
				> button > svg {
					width: 3rem;
					height: 3rem;
				}
			}

			& input {
				font-size: 1em !important;
			}

			& [view="price"] {
				font-size: 0.8em;
			}
		}
	}

	.subtotal {
		padding: 0;
		& hr { display: none; }
		& .block {
			justify-content: end;
			flex-wrap: wrap;
			gap: 0.5rem;
			padding: 0;
		}
		& .heading { }
	}

	.actions {
		padding-right: 0;
	}

	.terms, .terms-checkbox {
		padding: 0;
	}

	[part="checkout"], [part="clear-cart"] {
		font-size: 1em;
	}
}

@container (width < 20em) {
	.listing > li {
		position: relative;
		grid:
			"thumb  title"
			"remove quantity"
			"price  price"
			/ auto  minmax(1em, 1fr);
	}
	:is(.quantity, .remove) {
		align-self: center;
	}
	.quantity {
		margin-left: auto;
	}

	.actions {
		flex-direction: column;
	}
}

`;

function sum_subtotal([firstunit, ...units]) {
    var _a;
    const currencyCode = firstunit.variant.price.currencyCode;
    const first = get_values(firstunit);
    const totals = {
        price: first.price,
        comparison: (_a = first.comparison) !== null && _a !== void 0 ? _a : first.price,
    };
    for (const unit of units) {
        const { price, comparison } = get_values(unit);
        totals.price += price;
        totals.comparison += comparison !== null && comparison !== void 0 ? comparison : price;
    }
    return {
        price: {
            currencyCode,
            amount: totals.price.toString(),
        },
        compareAtPrice: (totals.price !== totals.comparison)
            ? {
                currencyCode,
                amount: totals.comparison.toString(),
            }
            : undefined,
    };
}
function get_values({ variant, quantity }) {
    return {
        price: parseFloat(variant.price.amount) * quantity,
        comparison: variant.compareAtPrice && parseFloat(variant.compareAtPrice.amount) * quantity,
    };
}

const styles$8 = css `

:host {
	display: block;
	height: max-content;
	width: max-content;
}

button {
	display: inline-flex;
	justify-content: center;
	align-items: center;
	width: 100%;

	cursor: pointer;
	user-select: none;
	padding: 0.2em 0.5em;
	font: inherit;
	font-weight: bold;
	border: none;
	border: 0.2em solid #fff8;
	border-radius: 0.5em;
	text-transform: uppercase;

	opacity: 0.7;
	color: white;
	background: #0b0;
	text-shadow: 0.1em 0.1em 0.1em #0004;

	&:is(:hover, :focus) {
		opacity: 0.9;
	}

	&:active {
		opacity: 1;
	}

	&[disabled] {
		opacity: 0.2;
		background: #888;
		color: white;
		cursor: default;
	}
}

`;

const Coolbutton = slate.shadow_view({
    name: "coolbutton",
    styles: styles$8,
}, _use => ({ active, text, onclick }) => html `

	<button
		part=button
		@click=${onclick}
		?disabled=${!active}>
		<slot part=slot></slot>
		${text}
	</button>

`);

const placeholder_img = {
    src: "https://i.imgur.com/h1v2noQ.webp",
    alt: "",
};

function prep(fun) {
    return (image) => image
        ? { src: fun(image), alt: image.altText }
        : placeholder_img;
}
const img = {
    tiny: prep(i => i.url_tiny),
    small: prep(i => i.url_small),
    medium: prep(i => i.url_medium),
    large: prep(i => i.url_large),
    original: prep(i => i.url_original),
};

function render_img({ img, part = "", onclick = () => { }, }) {
    return html `
		<img
			alt="${img.alt}"
			src="${img.src}"
			part="${part}"
			@click=${(event) => onclick(event, img)}
			/>
	`;
}

class ProductHelper {
    constructor(product) {
        this.product = product;
    }
    get images() {
        return this.product.images.edges.map(e => e.node);
    }
    get variants() {
        return this.product.variants.edges.map(e => e.node);
    }
    get first_variant() {
        return this.variants[0];
    }
    get featured_image() {
        const { product } = this;
        let image;
        const product_has_any_image_at_all = (product.featuredImage &&
            product.images.edges.length);
        if (product_has_any_image_at_all) {
            image = product.images.edges
                .map(e => e.node)
                .find(node => { var _a; return node.id === ((_a = product.featuredImage) === null || _a === void 0 ? void 0 : _a.id); });
        }
        return image;
    }
    get_variant(variant_id) {
        return this.variants.find(v => v.id === variant_id);
    }
    get_variant_image(variant_id) {
        const variant = this.get_variant(variant_id);
        if (variant && variant.image) {
            return this.images.find(i => i.id === variant.image.id);
        }
    }
    cross_reference_collections(all_collections) {
        const collections = [];
        const product_collection_records = this.product.collections.edges
            .map(e => e.node);
        for (const c of product_collection_records) {
            const found = all_collections.find(ac => ac.id === c.id);
            if (found)
                collections.push(found);
        }
        return collections;
    }
}

function icon(strings, ...values) {
    return (tag) => tag(strings, ...values);
}

var icon_x = icon `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;

const SheepCart = slate.shadow_component({ styles: style$2 }, use => {
    const { cart, shopify } = use.context;
    const { units } = use.context.cart;
    const state = use.flatstate({ termsChecked: false });
    const attrs = use.attrs({ "require-checkout-terms": Boolean });
    function render_unit(unit) {
        const producthelp = new ProductHelper(unit.product);
        const image = producthelp.get_variant_image(unit.variant_id);
        const variant = producthelp.get_variant(unit.variant_id);
        if (!variant)
            throw new Error("unknown variant");
        const handle_quantity_change = (e) => {
            const target = e.target;
            const quantity = parseInt(target.value);
            if (!isNaN(quantity))
                cart.set_quantity(unit.variant_id, quantity);
        };
        const handle_remove = () => {
            cart.remove(unit.variant_id);
        };
        const currencyCode = variant.price.currencyCode;
        const summed_pricing = {
            price: {
                currencyCode,
                amount: (parseFloat(variant.price.amount) * unit.quantity).toString(),
            },
            compareAtPrice: variant.compareAtPrice
                ? {
                    currencyCode,
                    amount: (parseFloat(variant.compareAtPrice.amount) * unit.quantity).toString(),
                }
                : undefined,
        };
        return html `
			<div class=thumb>
				${render_img({
            img: img.tiny(image),
            part: "img",
        })}
			</div>

			<div class=quantity>
				<input
					type=number
					min=1
					.value="${unit.quantity}"
					@change="${handle_quantity_change}"/>
			</div>

			<div class=title>
				<h3>${unit.product.title}</h3>
				${producthelp.variants.length > 1
            ? html `<p>${variant.title}</p>`
            : undefined}
			</div>

			<div class=price>
				${Price([summed_pricing], { attrs: { part: "price" } })}
			</div>

			<div class=remove>
				<button
					title="remove from cart"
					@click="${handle_remove}">
					${icon_x(b)}
				</button>
			</div>
		`;
    }
    async function checkout() {
        const line_items = (cart.units
            .map(({ variant_id, quantity }) => ({
            variant_id,
            quantity,
        })));
        const win = window.open("", "_blank");
        if (!win)
            throw new Error("error opening window");
        win.document.body.innerHTML = `
			<h1>
				loading checkout...
			</h1>
			<style>
				html, body {
					background: #888;
					color: white;
					padding: 10%;
				}
				h1 {
					text-align: center;
				}
			</style>
		`;
        const { webUrl } = await shopify.checkout({ line_items });
        win.location.href = webUrl;
        win.focus();
        cart.clear();
    }
    return html `
		<h2>
			${units.length > 0
        ? "Your Cart"
        : "Cart is Empty"}
		</h2>

		<ol class=listing>
			${units.map(unit => html `
				<li part=line-item data-gpart=line-item>
					${render_unit(unit)}
				</li>
			`)}
		</ol>

		${units.length > 0
        ? html `
				<div class=subtotal>
					<div class=group>
						<hr/>
						<div class=block>
							<div class=heading>
								Subtotal
							</div>
							<div class=price>
								${Price([sum_subtotal(units)], { attrs: { part: "price" } })}
							</div>
						</div>
					</div>
				</div>
				<slot class=terms name=terms></slot>
				${attrs["require-checkout-terms"] ? html `
					<div class=terms-checkbox>
						<label>
							<input type="checkbox" @input=${(event) => {
            const input = event.currentTarget;
            state.termsChecked = input.checked;
        }} />
							<slot name=terms-checkbox-label>
								I accept the terms above <em>(required for checkout)</em>
							</slot>
						</label>
					</div>
				` : undefined}
				<div class=actions>
					${Coolbutton([{
                active: attrs["require-checkout-terms"]
                    ? state.termsChecked
                    : true,
                text: "Checkout",
                onclick: checkout,
            }], { attrs: { part: "checkout" } })}
					${Coolbutton([{
                active: true,
                text: "clear cart",
                onclick: () => cart.clear(),
            }], { attrs: { part: "clear-cart" } })}
				</div>
			`
        : undefined}
	`;
});

var icon_x_circle = icon `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x-circle"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`;

const styles$7 = css `

dialog {
	margin: auto;
	margin-top: 2em;
	background: transparent;
	border: none;

	&::backdrop {
		background: #222222f8;
	}
}

.actions, sheep-cart {
	width: 86em;
	max-width: 100%;
	margin: 0.2em auto;
}

sheep-cart {
	padding: 1em;
}

.actions {
	display: flex;
	justify-content: end;
	align-items: center;

	pointer-events: none;

	> * {
		pointer-events: all;
	}
}

.close {
	font: inherit;
	background: transparent;
	color: #fffc;
	border: none;

	opacity: 0.7;
	cursor: pointer;

	&:focus { opacity: 0.8; }
	&:hover { opacity: 0.9; }
	&:active { opacity: 1; }

	> svg {
		width: 2em;
		height: 2em;
	}
}

.contents {
	padding: 1em;
	color: #fff;
	box-shadow: 1px 2px 5px #0008;

	> [part="img"] {
		position: fixed;
		max-width: 90vw;
		max-height: 90vh;
		inset: 0;
		margin: auto;

		cursor: pointer;
		user-select: none;
		border-radius: var(--sheep-border-radius, 0.2em);
	}
}

`;

const SheepModal = slate.shadow_component({ styles: styles$7 }, use => {
    const attrs = use.attrs({ "cart-require-checkout-terms": Boolean });
    use.setup(() => use.context.modal.on.open(o => open_modal(o)));
    const is_slotted = {
        cart_terms_checkbox_label: use.element.querySelector(`[slot="cart-terms-checkbox-label"]`),
    };
    function modal_dressing(id, content) {
        return html `
			<div class=actions>
				<button class=close @click=${() => close_modal(id)}>
					${icon_x_circle(b)}
				</button>
			</div>
			<div class=contents>
				${content}
			</div>
		`;
    }
    function distinguish_modal_details(id, modal) {
        switch (modal.kind) {
            case "image": {
                const { img: { src, alt } } = modal;
                const closer = () => close_modal(id);
                return {
                    on_backdrop_click: closer,
                    content: html `
						<img
							part=img
							src="${src}"
							alt="${alt}"
							@click=${closer} />
					`,
                };
            }
            case "cart": {
                return {
                    on_backdrop_click: () => close_modal(id),
                    content: html `
						<sheep-cart
							part=cart
							require-checkout-terms=${attrs["cart-require-checkout-terms"]}
							>
							<slot name=cart-terms slot=terms></slot>
							${is_slotted.cart_terms_checkbox_label ? html `
								<slot name=cart-terms-checkbox-label slot=terms-checkbox-label></slot>
							` : undefined}
						</sheep-cart>
					`,
                };
            }
        }
    }
    function open_modal({ id, modal }) {
        const dialog = document.createElement("dialog");
        dialog.setAttribute("data-id", id);
        const { content, on_backdrop_click } = (distinguish_modal_details(id, modal));
        dialog.onclick = event => {
            if (event.target === dialog)
                on_backdrop_click();
        };
        j(modal_dressing(id, content), dialog);
        use.shadow.appendChild(dialog);
        dialog.showModal();
    }
    function close_modal(id) {
        const dialog = use
            .shadow
            .querySelector(`[data-id="${id}"]`);
        if (dialog) {
            dialog.close();
            dialog.remove();
        }
    }
    return html ``;
});

var icon_search = icon `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>`;

const style$1 = css `

:host {
	display: flex;
	flex-direction: column;
	gap: 0.5em;
	--highlight: var(--sheep-highlight, lime);
}

.searchbox {
	position: relative;

	> input {
		display: block;
		font-size: 1.5em;
		width: 100%;
		min-width: 4em;
		max-width: 20em;
		background: transparent;
		border: 0.1em solid;
		border-radius: 0.5em;
		padding: 0.3em;
		padding-left: 2em;
		color: inherit;
		transition: transform 0.3s ease-in-out;

		&:focus {
			transform: scale(1.03);
		}
	}

	> svg {
		position: absolute;
		left: 0.5em;
		top: 0;
		bottom: 0;
		margin: auto;
		transition: all 0.3s ease-in-out;
	}

	&[data-active] {
		color: var(--highlight);
		+ svg {
			color: inherit;
		}
	}
}


.searchtags {
	display: flex;
	flex-wrap: wrap;
	gap: 0.1em;
	min-width: 0;

	> label {
		display: flex;
		align-items: center;
		border: 1px solid;
		border-radius: 1em;
		padding: 0 0.3em;
		min-width: 0;
		gap: 0.5em;

		& input {
			display: none;
			opacity: 0.5;
		}

		&[data-active] {
			color: var(--highlight);
			& input { opacity: 1; }
		}

		> span {
			font-size: 0.8em;
			user-select: none;
		}
	}
}

`;

function update_tag(tag, router) {
    return (event) => {
        const target = event.target;
        const terms = router.search_terms;
        const tag_set = new Set(router.search_tags);
        if (target.checked)
            tag_set.add(tag);
        else
            tag_set.delete(tag);
        const nada = tag_set.size === 0 && terms.length === 0;
        if (nada)
            router.routes.home().go();
        else
            router.routes.search(terms, [...tag_set]).go();
    };
}

function get_tag_data({ state }) {
    const { route, tags } = state;
    const active_tag_names = (route && route.zone === "search")
        ? route.tags
        : [];
    const is_tag_active = (tag) => {
        return active_tag_names.includes(tag);
    };
    const tag_data = tags.map(tag => ({
        tag,
        active: is_tag_active(tag),
    }));
    return tag_data;
}

function render_search_tags(context) {
    return html `
		${get_tag_data(context).map(({ tag, active }) => html `
			<label part="${part(active)}" data-tag="${tag}" ?data-active="${active}">
				<input
					type="checkbox"
					.checked="${active}"
					@input="${update_tag(tag, context.router)}"
					/>
				<span>${tag}</span>
			</label>
		`)}
	`;
}
function part(active) {
    return active
        ? "tag x-active"
        : "tag";
}

function ascertain_search_details(router, value) {
    const terms = value.split(/\s+/).filter(t => t.length);
    const tags = router.search_tags;
    const there_is_nothing_to_search_for = terms.length === 0 && tags.length === 0;
    return {
        terms,
        there_is_nothing_to_search_for,
    };
}

async function populate_input_with_route_search_terms(wait, router, get_input) {
    await wait;
    if (router.route.zone === "search")
        get_input().value = router.route.terms.join(" ");
}

function populate_input_with_route_search_terms_when_user_is_not_focused_on_input(route, user_is_focused_on_input, input) {
    const is_search = route.zone === "search";
    const not_focused = !user_is_focused_on_input;
    if (not_focused) {
        if (is_search)
            input.value = route.terms.join(" ");
        else
            input.value = "";
    }
}

const SheepSearch = slate.shadow_component({ styles: style$1 }, use => {
    const { router } = use.context;
    const is_search = router.route.zone === "search" && router.route.terms.length;
    function get_input() {
        return use.shadow.querySelector("input");
    }
    function get_user_is_focused_on_input() {
        return document.activeElement === use.element || use.element.contains(document.activeElement);
    }
    use.setup(() => {
        populate_input_with_route_search_terms(use.element.updateComplete.then(() => undefined), use.context.router, get_input);
        return use.context.router.on_route_change(route => populate_input_with_route_search_terms_when_user_is_not_focused_on_input(route, get_user_is_focused_on_input(), get_input()));
    });
    const search = debounce(250, () => {
        const { router } = use.context;
        const details = ascertain_search_details(router, get_input().value);
        if (details.there_is_nothing_to_search_for)
            router.routes.home().go();
        else
            router.routes.search(details.terms, router.search_tags).go();
    });
    return html `
		<div ?data-active=${is_search} class=searchbox>
			<input part=input type=text @input="${search}"/>
			${icon_search(b)}
		</div>
		<div class=searchtags>
			${render_search_tags(use.context)}
		</div>
	`;
});

var icon_loader = icon `<svg xmlns="http://www.w3.org/2000/svg" width = "24" height = "24" viewBox = "0 0 24 24" fill = "none" stroke = "currentColor" stroke - width="2" stroke - linecap="round" stroke - linejoin="round" class="feather feather-loader" > <line x1="12" y1 = "2" x2 = "12" y2 = "6" > </line><line x1="12" y1="18" x2="12" y2="22"></line > <line x1="4.93" y1 = "4.93" x2 = "7.76" y2 = "7.76" > </line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line > <line x1="2" y1 = "12" x2 = "6" y2 = "12" > </line><line x1="18" y1="12" x2="22" y2="12"></line > <line x1="4.93" y1 = "19.07" x2 = "7.76" y2 = "16.24" > </line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line > </svg>`;

var icon_alert_circle = icon `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-alert-circle"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>`;

const render_op = prep_render_op({
    loading: () => html `
		<span class="op loading">
			${icon_loader(b)}
		</span>
	`,
    error: reason => html `
		<span class="op error">
			${icon_alert_circle(b)}
			${reason}
		</span>
	`
});

const style = css `

:host {
	display: block;
}

[part="collection-tab-list"] {
	display: flex;
	margin-bottom: 1em;
	flex-wrap: wrap;
	justify-content: center;

	> [part="collection-tab"] {
		color: inherit;
		text-shadow: none;
		padding: 0.2em 0.5em;
		border-radius: 0.5em;
		font-size: 1.1em;
		text-decoration: none;
		transition: all 0.3s ease-in-out;
		font-weight: bold;
		-webkit-user-drag: none;
		user-drag: none;
		user-select: none;
		overflow: hidden;

		position: relative;

		> .bgimg {
			opacity: 0;
			z-index: 1;
			position: absolute;
			inset: 0;
			background-size: cover;
			background-position: top center;
			transition: all 1s ease;
		}

		> .text {
			z-index: 2;
			position: relative;
		}

		&[data-active-collection] {
			color: white;
			text-shadow: 0.05em 0.1em 0.1em #0008;
			box-shadow: 0.1em 0.2em 0.3em #0002;
			& > .bgimg {
				opacity: 0.5;
				background-position: center center;
			}
		}
	}
}

`;

const styles$6 = css `

:host {
	display: block;
	container-type: inline-size;
}

.collection_header {
	margin-bottom: 1em;
	text-align: center;
	text-transform: capitalize;
	font-size: 1.2rem;
}

.grid {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(16em, 1fr));
	width: 100%;
	gap: 0.5rem;
}

@container (width < 16em) {
	.grid {
		display: flex;
		flex-direction: column;
	}
}

[view="product-card"] {
	font-size: 0.8em;
	max-width: 100%;
}

footer {
	display: flex;
	padding: 1em;
	justify-content: center;
	align-items: center;

	> button {
		opacity: 0.7;
		font: inherit;
		text-transform: uppercase;
		font-size: 1em;
		padding: 1em 2em;
		background: #fffa;
		color: #000a;
		border: none;
		cursor: pointer;
		user-select: none;
		border-radius: 3em;
		&:is(:hover, :focus) { opacity: 0.8; }
		&:active { opacity: 1; }
	}
}

`;

const styles$5 = css `

:host > a {
	display: flex;
	width: 100%;
	height: 100%;
	gap: 0.5em;
	text-decoration: none;
	color: inherit;

	> img {
		flex: 1;
		max-width: 4rem;
		object-fit: cover;
		user-select: none;
	}

	> [part="plate"] {
		display: flex;
		flex-direction: column;
		flex: 1 1 auto;
		gap: 0.5em;

		> h1 {
			font-size: 1.2em;
		}

		> .action {
			display: flex;
			margin-top: auto;
			gap: 0.5em;
			align-items: end;
			flex-wrap: wrap-reverse;

			> .button {
				flex: 1 1 6em;
				width: 100%;
				max-width: 10em;

				&::part(button) {
					min-height: 3em;
				}

				&::part(slot) {
					display: flex;
					flex-direction: column;
					justify-content: center;
				}

				small {
					font-weight: normal;
				}
			}

			> .pricebox {
				margin-left: auto;
			}
		}
	}
}

`;

const styles$4 = css `

ol {
	display: flex;
	flex-wrap: wrap;
	list-style: none;
	gap: 0.1em;
}

li {
	border: 1px solid currentColor;
	padding: 0 0.3em;

	&[part="collection"] {
		border-radius: 0.3em;
	}

	&[part="tag"] {
		opacity: 0.7;
		border-radius: 1em;
	}
}

`;

const Pills = slate.shadow_view({
    name: "pills",
    styles: styles$4,
}, use => (product) => {
    const productHelper = new ProductHelper(product);
    const collections = productHelper
        .cross_reference_collections(use.context.state.collections);
    return html `
		<ol part=list>

			${collections.map(collection => html `
				<li part=collection>${collection.title}</li>
			`)}

			${product.tags.map(tag => html `
				<li part=tag>${tag}</li>
			`)}
		</ol>
	`;
});

function display_price({ product, single_price, multiple_prices, }) {
    const more_than_one_variant = product.variants.edges.length > 1;
    const all_the_same_price = product.variants.edges
        .every(p => p.node.price.amount === product.variants.edges[0].node.price.amount);
    function numerical(price) {
        return parseFloat(price.amount);
    }
    const variants = product.variants.edges.map(e => e.node);
    let cheapest_variant = variants[0];
    for (const variant of variants) {
        if (numerical(variant.price) < numerical(cheapest_variant.price))
            cheapest_variant = variant;
    }
    return (more_than_one_variant && !all_the_same_price)
        ? multiple_prices(cheapest_variant)
        : single_price(cheapest_variant);
}

function add_button({ cart, product, variant_id, allow_select, Coolbutton, }) {
    const number_of_variants = product
        .variants
        .edges
        .length;
    const variant = product
        .variants
        .edges
        .map(e => e.node)
        .find(v => v.id === variant_id);
    const unit = cart
        .units
        .find(u => u.variant_id === variant_id);
    const button_type = (allow_select && number_of_variants > 1)
        ? "select_from_variants"
        : unit
            ? "in_cart"
            : variant.availableForSale
                ? "add_to_cart"
                : "sold_out";
    switch (button_type) {
        case "select_from_variants":
            return Coolbutton([{ active: true, onclick: () => { } }], {
                attrs: {
                    part: "addbutton x-select-from-variants",
                    gpart: "addbutton x-select-from-variants",
                },
                content: html `
					${number_of_variants} Options
				`,
            });
        case "in_cart":
            return Coolbutton([{ active: false, onclick: () => { } }], {
                attrs: {
                    part: "addbutton x-in-cart",
                    gpart: "addbutton x-in-cart",
                },
                content: html `
					in cart
				`,
            });
        case "add_to_cart":
            return Coolbutton([{
                    active: true,
                    onclick: event => {
                        event.preventDefault();
                        cart.add(variant_id, product);
                    },
                }], {
                attrs: {
                    part: "addbutton x-add-to-cart",
                    gpart: "addbutton x-add-to-cart",
                },
                content: html `
					Add to Cart
				`,
            });
        case "sold_out":
            return Coolbutton([{ active: false, onclick: () => { } }], {
                attrs: {
                    part: "addbutton x-sold-out",
                    gpart: "addbutton x-sold-out",
                },
                content: html `
					Sold Out
				`,
            });
        default:
            throw new Error(`unknown button type "${button_type}"`);
    }
}

const ProductCard = slate.shadow_view({
    styles: styles$5,
    name: "product-card",
}, use => (product) => html `

	<a href="${use.context.router.routes.product(product).url}">

		${render_img({
    part: "img",
    img: img.tiny(new ProductHelper(product).featured_image),
})}

		<div part=plate>
			<h1 part="title a" data-gpart="a">
				${product.title}
			</h1>

			${Pills([product], { attrs: { part: "pills", gpart: "pills" } })}

			<div class=action>
				${add_button({
    product,
    cart: use.context.cart,
    allow_select: true,
    Coolbutton,
    variant_id: new ProductHelper(product).first_variant.id,
})}

				<div class=pricebox>
					${display_price({
    product,
    single_price: variant => html `
							${Price([variant], { attrs: { part: "price singleprice" } })}
						`,
    multiple_prices: variant => html `
							<div class=info>starts at</div>
							${Price([variant], { attrs: { part: "price multiprice" } })}
						`,
})}
				</div>

			</div>
		</div>
	</a>
`);

const ProductList = slate.shadow_view({
    styles: styles$6,
    name: "product-list",
}, _use => ({ situation: { products, load_more_op, load_more } }) => (((products.length > 0)
    ? html `
				<div class=grid>
					${products.map(product => ProductCard([product], { attrs: { part: "card", gpart: "card" } }))}
				</div>

				<footer>
					${render_op(load_more_op, () => load_more
        ? html `<button @click=${load_more}>load more</button>`
        : undefined)}
				</footer>
			`
    : html `
				<p>No products found</p>
			`)));

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */class e extends i{constructor(i){if(super(i),this.et=T,i.type!==t.CHILD)throw Error(this.constructor.directiveName+"() can only be used in child bindings")}render(r){if(r===T||null==r)return this.vt=void 0,this.et=r;if(r===w)return r;if("string"!=typeof r)throw Error(this.constructor.directiveName+"() called with a non-string value");if(r===this.et)return this.vt;this.et=r;const s=[r];return s.raw=s,this.vt={_$litType$:this.constructor.resultType,strings:s,values:[]}}}e.directiveName="unsafeHTML",e.resultType=1;const o=e$1(e);

const styles$3 = css `

:host {
	display: block;
	container-type: inline-size;
	--border-radius: var(--sheep-border-radius, 0.2em);
	--frame-padding: var(--sheep-frame-padding, 1em);
	--frame-background: var(--sheep-frame-background, #fff2);
}

[part="grid"] {
	display: grid;
	gap: 1em;
	grid:
		"feature feature feature .       .       .      " 1fr
		"feature feature feature heading heading heading"
		"feature feature feature pills   pills   pills  "
		"feature feature feature options options options"
		"feature feature feature buy     buy     buy    "
		"feature feature feature .       .       .      " 1fr
		"essay   essay   essay   essay   essay   essay  "
		"images  images  images  images  images  images ";
	grid-template-columns: repeat(auto-fit, minmax(1em, 1fr));
	align-items: start;
}

@container (width < 30em) {
	[part="grid"] {
		grid:
			"feature"
			"heading"
			"pills"
			"options"
			"buy"
			"essay"
			"images"
			/ 1fr;
		grid-template-columns: repeat(auto-fit, minmax(1em, 1fr));
	}
}

@container (width < 30em) {
	[part="aside"] > img {
		width: 50cqi;
		height: 50cqi;
	}
}

[part="grid"] {
	> figure { grid-area: feature; }
	> h1 { grid-area: heading; }
	> .pills { grid-area: pills; }
	> .options { grid-area: options; }
	> .buy { grid-area: buy; }
	> aside { grid-area: images; }
	> section {
		grid-area: essay;
		max-width: 48em;
		justify-self: center;
		line-height: 1.5;
	}

	> figure {
		padding: var(--frame-padding);
		background: var(--frame-background);
		width: 100%;
		height: 100%;
		align-self: center;
		justify-self: end;

		> img {
			display: block;
			width: 100%;
			height: 100%;
			object-fit: cover;
			user-select: none;
			border-radius: var(--border-radius);
		}
	}

	> h1 {
		font-size: 2em;
	}

	> .pills {
		font-size: 0.8em;
	}

	> .options {
		font-size: 1.2em;
		justify-self: end;

		display: flex;
		flex-direction: column;
		align-items: end;
		gap: 1em;
		padding: 1em;

		& select {
			padding: 0.5em;
			margin-left: 1em;
		}
	}

	.buy {
		display: flex;
		justify-content: end;
		font-size: 1em;
		gap: 1rem;

		> .price {
			flex: 1;
			display: flex;
			justify-content: center;
		}

		> [view="coolbutton"] {
			flex: 2;
			&::part(button) {
				padding: 1em;
			}
		}
	}

	> aside {
		display: flex;
		flex-wrap: wrap;
		container-type: inline-size;
		padding: var(--frame-padding);
		background: var(--frame-background);
		justify-content: center;

		> img {
			display: block;
			width: 25cqi;
			height: 25cqi;
			aspect-ratio: 1 / 1;
			object-fit: cover;
			user-select: none;
			border-radius: var(--border-radius);
		}
	}

	&[data-no-additional-images] {
		> aside {
			display: none;
		}
		> section {
			grid-area: images / images / essay / essay;
		}
	}

	&[data-no-options] {
		> .options {
			display: none;
		}
		> .pills {
			grid-row: span 2;
		}
	}
}

[part="recbox"] {
	margin-top: 4em;

	> h2 {
		text-align: center;
		margin-bottom: 1em;
	}

	> [view="product-recommendation"] {
		justify-content: center;
	}
}

`;

class ChoiceHelper {
    constructor(productHelper, choices) {
        this.productHelper = productHelper;
        this.choices = choices;
    }
    get_choice(name) {
        var _a;
        const { productHelper, choices } = this;
        const initial_choices = productHelper.first_variant.selectedOptions;
        const found = (_a = choices.find(choice => choice.name === name)) !== null && _a !== void 0 ? _a : initial_choices.find(choice => choice.name === name);
        if (!found)
            throw new Error(`choice not found (${name})`);
        return found.value;
    }
    get selected_variant() {
        var _a;
        const { productHelper } = this;
        return (_a = (productHelper.variants
            .find(variant => variant.selectedOptions
            .every(({ name, value }) => value === this.get_choice(name))))) !== null && _a !== void 0 ? _a : productHelper.first_variant;
    }
    get chosen_image() {
        const { productHelper } = this;
        const variant = this.selected_variant;
        let image;
        if (variant.image)
            image = productHelper.images
                .find(i => i.id === variant.image.id);
        if (!image)
            image = productHelper.featured_image;
        return image;
    }
    get side_images() {
        const primary_image = this.chosen_image;
        return this.productHelper.images
            .filter(image => image.id !== (primary_image === null || primary_image === void 0 ? void 0 : primary_image.id));
    }
}

function render_options(choiceHelper, set_choice) {
    const { productHelper: { product } } = choiceHelper;
    function is_selected(name, value) {
        return value === choiceHelper.get_choice(name);
    }
    function handle_input(name) {
        return (event) => {
            const target = event.target;
            set_choice(name, target.value);
        };
    }
    return product.options.map(({ name, values }) => html `
		<label>
			<span>${name}</span>
			<select @input=${handle_input(name)}>
				${values.map(value => html `
					<option ?selected=${is_selected(name, value)}>
						${value}
					</option>
				`)}
			</select>
		</label>
	`);
}

const styles$2 = css `

:host {
	display: flex;
	flex-wrap: wrap;
	gap: 1em;
}

[view="product-card"] {
	flex: 30%;
	min-width: 18em;
	max-width: 30em;
}

`;

const ProductRecommendation = slate.shadow_view({
    styles: styles$2,
    name: "product-recommendation",
}, use => (id, count) => {
    const state = use.flatstate({ recommendations: [] });
    use.setup(() => {
        void async function () {
            const products = await use.context
                .shopify
                .product_recommendations({ product_id: id });
            state.recommendations = products;
        }();
        return () => { };
    });
    return html `
		${state.recommendations.slice(0, count).map(r => ProductCard([r], { attrs: { part: "card", gpart: "card" } }))}
	`;
});

const ProductFocus = slate.shadow_view({
    styles: styles$3,
    name: "product-focus",
}, use => (product) => {
    const { cart, modal } = use.context;
    const state = use.flatstate({
        choices: [],
    });
    const productHelper = new ProductHelper(product);
    const choiceHelper = new ChoiceHelper(productHelper, state.choices);
    function set_choice(name, value) {
        state.choices = state.choices
            .filter(choice => choice.name !== name);
        if (value !== undefined)
            state.choices.push({ name, value });
    }
    return html `
		<div
			part=grid
			?data-no-additional-images=${productHelper.images.length < 2}
			?data-no-options=${productHelper.variants.length < 2}>

			<figure part=figure>
				${render_img({
        part: "img",
        img: img.large(choiceHelper.chosen_image),
        onclick: (_, img) => (modal.open({
            kind: "image",
            img,
        })),
    })}
			</figure>

			<h1 part=title>${product.title}</h1>

			${Pills([product], { attrs: { class: "pills", part: "pills", gpart: "pills" } })}

			<div part=options class=options>
				${render_options(choiceHelper, set_choice)}
			</div>

			<div part=buy class=buy>
				${Price([choiceHelper.selected_variant], { attrs: { class: "price" } })}
				${add_button({
        Coolbutton,
        cart,
        product,
        variant_id: choiceHelper.selected_variant.id,
        allow_select: false,
    })}
			</div>

			<aside part=aside class=aside>
				${choiceHelper.side_images.map(image => render_img({
        part: "img",
        img: img.large(image),
        onclick: (_, img) => (modal.open({
            kind: "image",
            img,
        })),
    }))}
			</aside>

			<section part=standard-content class="standard-content">
				${o(product.descriptionHtml)}
			</section>

		</div>
		<div part=recbox class=recommendations>
			<h2>Customers also bought:</h2>
			${ProductRecommendation([product.id, 3], {
        attrs: {
            part: "recommendations",
        },
    })}
		</div>
	`;
});

function bg_img(collection) {
    return collection.image
        ? `background-image: url("${collection.image.url_small}");`
        : "";
}

const styles$1 = css `

:host {
	display: block;
	container: collection-list / inline-size;
}

[part="grid"] {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(24em, 1fr));
	gap: 1em;
	--plate-color: var(--collection-list-plate-color, #8884);
}

[part="grid"] > a {
	padding: 1em 2em;
	background-color: var(--plate-color);
	background-size: cover, cover;
	background-position: center center, center center;
	color: white;
	font-weight: bold;
	border-radius: 0.5em;
	box-shadow: 0.1em 0.2em 0.5em #0004;

	font-size: 1.5em;
	color: white;
	text-decoration: none;
	text-shadow:
		0.05em 0.10em 0.5em black,
		0.05em 0.10em 0.5em black,
		0.05em 0.10em 0 black;

	&:hover { text-decoration: underline; }
	&:active { text-decoration: double underline; }
}

@container collection-list (width < 30em) {
	[part="grid"] {
		display: flex;
		flex-direction: column;
	}
}

@container collection-list (width < 16em) {
	[part="grid"] > a {
		font-size: 1.2em;
		padding: 0.5em 1em;
	}
}

`;

function sort_collections(collections, prioritized_ids, hidden_ids) {
    let prioritized = [];
    let unprioritized = [];
    for (const collection of collections) {
        if (prioritized_ids.includes(collection.id))
            prioritized.push(collection);
        else
            unprioritized.push(collection);
    }
    const prioritized_in_order = prioritized_ids
        .map(id => prioritized.find(c => c.id === id))
        .filter(c => !!c);
    const unprioritized_in_order = unprioritized
        .sort(alphabetize);
    return [
        ...prioritized_in_order,
        ...unprioritized_in_order,
    ].filter(c => !hidden_ids.includes(c.id));
}
function alphabetize(a, b) {
    return a.title.localeCompare(b.title);
}

const CollectionList = slate.shadow_view({
    name: "collection-list",
    styles: styles$1,
}, use => ({ collections, prioritized, hidden }) => html `

	<div part=grid>
		${sort_collections(collections, prioritized, hidden)
    .map(collection => html `
				<a
					part=bar
					data-id="${collection.id}"
					style="${bg_img(collection)}"
					href="${use.context.router.routes.collection(collection).url}">
					${collection.title}
				</a>
			`)}
	</div>
`);

function process_comma_list(raw) {
    return raw
        ? raw.split(/\s+/).map(id => id.trim())
        : [];
}

const SheepCatalog = slate.shadow_component({ styles: style }, use => {
    const { state, router } = use.context;
    const attrs = use.attrs({
        "prioritized-collections": String,
        "hidden-collections": String,
    });
    function get_option_attributes() {
        return {
            hidden: process_comma_list(attrs["hidden-collections"]),
            prioritized: process_comma_list(attrs["prioritized-collections"]),
        };
    }
    function render_collections_tabs(prioritized, hidden) {
        const active_collection_id = state.route.zone === "collection"
            ? state.route.id
            : undefined;
        if (!active_collection_id)
            return undefined;
        const collections = sort_collections(state.collections, prioritized, hidden);
        return html `
			<div part=collection-tab-list>
				${collections.map(collection => html `
					<a
						part=collection-tab
						href="${router.routes.collection(collection).url}"
						?data-active-collection=${collection.id === active_collection_id}>
						<span class=bgimg style="${bg_img(collection)}"></span>
						<span class=text>${collection.title}</span>
					</a>
				`)}
			</div>
		`;
    }
    const { hidden, prioritized } = get_option_attributes();
    return html `
		<div>
			${render_collections_tabs(prioritized, hidden)}
			${render_op(state.situation_op, situation => {
        switch (situation === null || situation === void 0 ? void 0 : situation.type) {
            case "collection_list":
                return CollectionList([{
                        hidden,
                        prioritized,
                        collections: situation.collections,
                    }], { attrs: { part: "collection-list" } });
            case "products_in_collection": {
                return ProductList([{ situation }], { attrs: { part: "product-list" } });
            }
            case "all_products":
                return ProductList([{ situation }], { attrs: { part: "product-list" } });
            case "search_results":
                return ProductList([{ situation }], { attrs: { part: "product-list" } });
            case "single_product":
                return ProductFocus([situation.product], { attrs: { part: "product-focus" } });
            case "not_found":
                return html `
							${situation.message
                    ? html `<h1>${situation.message}</h1>`
                    : html `<h1>Not found</h1>`}
							<p>
								<a part=a href="${router.routes.home().url}">
									back
								</a>
							</p>
						`;
            default:
                return undefined;
        }
    })}
		</div>
	`;
});

var icon_shopping_cart = icon `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-shopping-cart"><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg>`;

const styles = css `

button {
	position: relative;
	padding: 1em;
	background: #eeee;
	color: #222;
	border: none;
	border-radius: 1em;
	box-shadow: 0.1em 0.1em 0.3em #0008;
	cursor: pointer;
}

.count {
	position: absolute;
	top: -0.5em;
	right: -0.5em;
	display: flex;
	justify-content: center;
	align-items: center;
	width: 1.5em;
	height: 1.5em;
	border-radius: 1em;
	background: red;
	font-family: sans-serif;
	font-weight: bold;
	color: white;
	text-shadow: 0.1em 0.1em 0.1em #0008;
	&[hidden] { display: none; }
}

`;

const SheepCartButton = slate.shadow_component({ styles }, use => {
    const attrs = use.attrs({ "triggers-modal": Boolean });
    const { units } = use.context.cart;
    const onclick = attrs["triggers-modal"]
        ? () => use.context.modal.open({ kind: "cart" })
        : () => { };
    return html `
		<button
			part=button
			@click=${onclick}>

			${icon_shopping_cart(b)}

			<div class=count ?hidden=${units.length === 0}>
				${units.length}
			</div>
		</button>
	`;
});

const elements = {
    SheepNav,
    SheepCart,
    SheepModal,
    SheepSearch,
    SheepCatalog,
    SheepCartButton,
};

async function load_single_product(set_situation_op, product) {
    await Op.run(set_situation_op, async () => {
        try {
            return {
                type: "single_product",
                product: await product,
            };
        }
        catch (error) {
            if (error instanceof ShopifyNotFoundError)
                return {
                    type: "not_found",
                    message: "Product not found",
                };
            else
                throw error;
        }
    });
}

async function load_products_with_recursive_apparatus({ subject, wrap, set_situation_op, generator, previous_products = [], }) {
    const this_is_the_initial_listing_call = previous_products.length === 0;
    async function load_next_page_of_products() {
        try {
            const { value } = await generator.next();
            const [new_products, more] = value;
            const products = [...previous_products, ...new_products];
            const load_more = more
                ? () => load_products_with_recursive_apparatus({
                    subject,
                    wrap,
                    set_situation_op,
                    generator,
                    previous_products: products,
                })
                : undefined;
            return wrap({
                products,
                load_more,
                load_more_op: Op.ready(undefined),
            });
        }
        catch (error) {
            if (error instanceof ShopifyNotFoundError)
                return {
                    type: "not_found",
                    message: `${subject} not found`,
                };
            else
                throw error;
        }
    }
    if (this_is_the_initial_listing_call) {
        await Op.run(set_situation_op, async () => await load_next_page_of_products());
    }
    else {
        set_situation_op(Op.ready(wrap({
            products: previous_products,
            load_more: undefined,
            load_more_op: Op.loading(),
        })));
        set_situation_op(Op.ready(await load_next_page_of_products()));
    }
}

const prepare_pilot = (params) => (route) => {
    const { home, shopify, page_size, collections_promise, set_situation_op, } = params;
    function go_collections() {
        return Op.run(op => set_situation_op(Op.morph(op, collections => ({
            type: "collection_list",
            collections,
        }))), async () => collections_promise);
    }
    function go_products() {
        return load_products_with_recursive_apparatus({
            subject: "Products",
            wrap: list => ({ ...list, type: "all_products" }),
            set_situation_op,
            generator: shopify.products({ page_size }),
        });
    }
    try {
        switch (route.zone) {
            case "home":
                return home === "products"
                    ? go_products()
                    : go_collections();
            case "products":
                return go_products();
            case "collections":
                return go_collections();
            case "search":
                return load_products_with_recursive_apparatus({
                    subject: "Products",
                    wrap: list => ({ ...list, type: "search_results" }),
                    set_situation_op,
                    generator: shopify.products({
                        page_size,
                        query: {
                            tags: route.tags,
                            terms: route.terms,
                        },
                    })
                });
            case "collection":
                return load_products_with_recursive_apparatus({
                    subject: "Collection",
                    wrap: list => ({
                        ...list,
                        type: "products_in_collection",
                        collection_id: route.id,
                    }),
                    set_situation_op,
                    generator: shopify.products_in_collection({
                        page_size,
                        collection_id: route.id,
                    })
                });
            case "product":
                return load_single_product(set_situation_op, shopify.product({ id: route.id }));
            case "not_found":
                return set_situation_op(Op.ready({ type: "not_found" }));
        }
    }
    catch (error) {
        console.error("pilot error", error);
    }
};

var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CartStore_key, _CartStore_storage;
class CartStore {
    constructor(key, storage) {
        _CartStore_key.set(this, void 0);
        _CartStore_storage.set(this, void 0);
        __classPrivateFieldSet(this, _CartStore_key, key, "f");
        __classPrivateFieldSet(this, _CartStore_storage, storage, "f");
    }
    save(pack) {
        const v1 = {
            version: 1,
            pack,
        };
        __classPrivateFieldGet(this, _CartStore_storage, "f").setItem(__classPrivateFieldGet(this, _CartStore_key, "f"), JSON.stringify(v1));
    }
    load() {
        let pack = { items: [] };
        const text = __classPrivateFieldGet(this, _CartStore_storage, "f").getItem(__classPrivateFieldGet(this, _CartStore_key, "f"));
        if (text) {
            try {
                const data = JSON.parse(text);
                if (data.version === 1)
                    pack = data.pack;
            }
            catch (err) { }
        }
        return pack;
    }
}
_CartStore_key = new WeakMap(), _CartStore_storage = new WeakMap();

const theme = css `

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

:not(:defined) {
	display: none;
}

.standard-content {
	& * + * {
		margin-top: 0.7em;
	}

	:is(ul, ol) {
		padding-left: 1.2em;
	}
}

.op {
	& svg {
		width: 2em;
		height: 2em;
	}

	&.error {
		display: flex;
		color: red;
		align-items: center;
		& svg {
			margin-right: 0.5em;
		}
	}

	&.loading svg {
		animation: rotate-animation 10s infinite linear;
	}
}

@keyframes rotate-animation {
	0% {
		transform: rotate(0deg);
	}
	50% {
		transform: rotate(180deg);
	}
	100% {
		transform: rotate(360deg);
	}
}

`;

function install_sheep_cart({ domain, storefront_access_token, page_size = 50, home = "products", theme: theme$1 = theme, }) {
    const shopify = Shopify.setup({
        domain,
        storefront_access_token,
    });
    const router = Router.setup(home);
    const context = new Context(shopify, router, theme$1, new CartStore("sheep_cart", localStorage));
    slate.context = context;
    context.cart.load();
    window.addEventListener("storage", () => {
        context.cart.load();
    });
    const collections_promise = Shopify.all(shopify.collections());
    const pilot = prepare_pilot({
        home,
        shopify,
        page_size,
        collections_promise,
        set_situation_op: context.set_situation_op,
    });
    router.on_route_change(context.set_route);
    router.on_route_change(() => pilot(context.state.route));
    return {
        elements,
        async load() {
            await Promise.all([
                void async function load_the_initial_route() {
                    await pilot(context.state.route);
                }(),
                void async function load_product_tags() {
                    context.set_tags(await Shopify.all(shopify.tags()));
                }(),
                void async function load_product_collections() {
                    context.set_collections(await collections_promise);
                }(),
            ]);
        },
    };
}

const sheep = install_sheep_cart({
    domain: "dev-bakery.myshopify.com",
    storefront_access_token: "5f636be6b04aeb2a7b96fe9306386f25",
    page_size: 10,
    home: "collections",
});
register_to_dom(sheep.elements);
await sheep.load();
console.log("🐑");
