import { StateTree } from "../state_tree.js";
export declare namespace ZipAction {
    type Blueprint<S> = {
        [key: string]: Blueprint<S> | Fn<S, any>;
    };
    type SetState<S> = (state: S) => void;
    type Fn<S, P extends any[]> = ((state: S, setState: (newState: S) => void) => (...params: P) => void);
    type Callable<B extends Blueprint<any>> = {
        [P in keyof B]: B[P] extends Blueprint<any> ? Callable<B[P]> : B[P] extends Fn<any, any> ? ReturnType<B[P]> : never;
    };
    function actualize<S, B extends Blueprint<S>>(tree: StateTree<S>, blueprint: B): Callable<B>;
    function fn<S>(): <F extends Fn<S, any[]>>(fn: F) => F;
    function blueprint<S>(): <B extends Blueprint<S>>(blueprint: B) => B;
    type Helpers<S, H> = (state: S, setState: ZipAction.SetState<S>) => H;
    const prepFn: <S, H>(helpers: Helpers<S, H>) => <P extends any[]>(fun: (helpers: H) => (...params: P) => void) => Fn<S, P>;
    const prepBlueprint: <S, H>(helpers: Helpers<S, H>) => <B extends Blueprint<S>>(makeBp: (action: <P extends any[]>(f: (helpers: H) => (...params: P) => void) => Fn<S, P>) => B) => B;
    function prep<S, H>(helpers: Helpers<S, H>): {
        action: <P extends any[]>(fun: (helpers: H) => (...params: P) => void) => Fn<S, P>;
        blueprint: <B extends Blueprint<S>>(makeBp: (action: <P_1 extends any[]>(f: (helpers: H) => (...params: P_1) => void) => Fn<S, P_1>) => B) => B;
    };
}
