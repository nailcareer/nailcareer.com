var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _WatchTower_signals, _WatchTower_computeds, _WatchTower_listeners, _WatchTower_memory;
import { StateTree } from "./state_tree.js";
import { deepEqual } from "../tools/deep_equal/deep_equal.js";
export class WatchTower {
    constructor(signals) {
        _WatchTower_signals.set(this, void 0);
        _WatchTower_computeds.set(this, new Set());
        _WatchTower_listeners.set(this, new Set());
        _WatchTower_memory.set(this, new Map());
        __classPrivateFieldSet(this, _WatchTower_signals, signals, "f");
    }
    dispatch() {
        for (const computed of __classPrivateFieldGet(this, _WatchTower_computeds, "f"))
            computed();
        for (const listener of __classPrivateFieldGet(this, _WatchTower_listeners, "f"))
            listener();
    }
    computed(fun) {
        const box = __classPrivateFieldGet(this, _WatchTower_signals, "f").signal(fun());
        __classPrivateFieldGet(this, _WatchTower_computeds, "f").add(() => { box.value = fun(); });
        return box;
    }
    track(collector, responder) {
        let first = true;
        const listener = () => {
            const current = collector();
            const previous = __classPrivateFieldGet(this, _WatchTower_memory, "f").get(collector);
            if (first || !deepEqual(current, previous)) {
                first = false;
                __classPrivateFieldGet(this, _WatchTower_memory, "f").set(collector, current);
                responder(current);
            }
        };
        listener();
        __classPrivateFieldGet(this, _WatchTower_listeners, "f").add(listener);
        return collector();
    }
    stateTree(state) {
        return new StateTree(state, () => this.dispatch());
    }
}
_WatchTower_signals = new WeakMap(), _WatchTower_computeds = new WeakMap(), _WatchTower_listeners = new WeakMap(), _WatchTower_memory = new WeakMap();
//# sourceMappingURL=tower.js.map