
	Array.prototype.at = function(index) {
		return index >= 0
			? this[index]
			: this[this.length + index]
	}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2=globalThis,e$3=t$2.ShadowRoot&&(void 0===t$2.ShadyCSS||t$2.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$3=Symbol(),o$3=new WeakMap;let n$3 = class n{constructor(t,e,o){if(this._$cssResult$=!0,o!==s$3)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=e;}get styleSheet(){let t=this.o;const s=this.t;if(e$3&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=o$3.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&o$3.set(s,t));}return t}toString(){return this.cssText}};const r$4=t=>new n$3("string"==typeof t?t:t+"",void 0,s$3),i$3=(t,...e)=>{const o=1===t.length?t[0]:e.reduce(((e,s,o)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(s)+t[o+1]),t[0]);return new n$3(o,t,s$3)},S$1=(s,o)=>{if(e$3)s.adoptedStyleSheets=o.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet));else for(const e of o){const o=document.createElement("style"),n=t$2.litNonce;void 0!==n&&o.setAttribute("nonce",n),o.textContent=e.cssText,s.appendChild(o);}},c$3=e$3?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const s of t.cssRules)e+=s.cssText;return r$4(e)})(t):t;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{is:i$2,defineProperty:e$2,getOwnPropertyDescriptor:r$3,getOwnPropertyNames:h$2,getOwnPropertySymbols:o$2,getPrototypeOf:n$2}=Object,a$1=globalThis,c$2=a$1.trustedTypes,l$1=c$2?c$2.emptyScript:"",p$1=a$1.reactiveElementPolyfillSupport,d$1=(t,s)=>t,u$1={toAttribute(t,s){switch(s){case Boolean:t=t?l$1:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,s){let i=t;switch(s){case Boolean:i=null!==t;break;case Number:i=null===t?null:Number(t);break;case Object:case Array:try{i=JSON.parse(t);}catch(t){i=null;}}return i}},f$3=(t,s)=>!i$2(t,s),y$1={attribute:!0,type:String,converter:u$1,reflect:!1,hasChanged:f$3};Symbol.metadata??=Symbol("metadata"),a$1.litPropertyMetadata??=new WeakMap;class b extends HTMLElement{static addInitializer(t){this._$Ei(),(this.l??=[]).push(t);}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(t,s=y$1){if(s.state&&(s.attribute=!1),this._$Ei(),this.elementProperties.set(t,s),!s.noAccessor){const i=Symbol(),r=this.getPropertyDescriptor(t,i,s);void 0!==r&&e$2(this.prototype,t,r);}}static getPropertyDescriptor(t,s,i){const{get:e,set:h}=r$3(this.prototype,t)??{get(){return this[s]},set(t){this[s]=t;}};return {get(){return e?.call(this)},set(s){const r=e?.call(this);h.call(this,s),this.requestUpdate(t,r,i);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)??y$1}static _$Ei(){if(this.hasOwnProperty(d$1("elementProperties")))return;const t=n$2(this);t.finalize(),void 0!==t.l&&(this.l=[...t.l]),this.elementProperties=new Map(t.elementProperties);}static finalize(){if(this.hasOwnProperty(d$1("finalized")))return;if(this.finalized=!0,this._$Ei(),this.hasOwnProperty(d$1("properties"))){const t=this.properties,s=[...h$2(t),...o$2(t)];for(const i of s)this.createProperty(i,t[i]);}const t=this[Symbol.metadata];if(null!==t){const s=litPropertyMetadata.get(t);if(void 0!==s)for(const[t,i]of s)this.elementProperties.set(t,i);}this._$Eh=new Map;for(const[t,s]of this.elementProperties){const i=this._$Eu(t,s);void 0!==i&&this._$Eh.set(i,t);}this.elementStyles=this.finalizeStyles(this.styles);}static finalizeStyles(s){const i=[];if(Array.isArray(s)){const e=new Set(s.flat(1/0).reverse());for(const s of e)i.unshift(c$3(s));}else void 0!==s&&i.push(c$3(s));return i}static _$Eu(t,s){const i=s.attribute;return !1===i?void 0:"string"==typeof i?i:"string"==typeof t?t.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Em=null,this._$Ev();}_$Ev(){this._$Eg=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$E_(),this.requestUpdate(),this.constructor.l?.forEach((t=>t(this)));}addController(t){(this._$ES??=[]).push(t),void 0!==this.renderRoot&&this.isConnected&&t.hostConnected?.();}removeController(t){this._$ES?.splice(this._$ES.indexOf(t)>>>0,1);}_$E_(){const t=new Map,s=this.constructor.elementProperties;for(const i of s.keys())this.hasOwnProperty(i)&&(t.set(i,this[i]),delete this[i]);t.size>0&&(this._$Ep=t);}createRenderRoot(){const t=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return S$1(t,this.constructor.elementStyles),t}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(!0),this._$ES?.forEach((t=>t.hostConnected?.()));}enableUpdating(t){}disconnectedCallback(){this._$ES?.forEach((t=>t.hostDisconnected?.()));}attributeChangedCallback(t,s,i){this._$AK(t,i);}_$EO(t,s){const i=this.constructor.elementProperties.get(t),e=this.constructor._$Eu(t,i);if(void 0!==e&&!0===i.reflect){const r=(void 0!==i.converter?.toAttribute?i.converter:u$1).toAttribute(s,i.type);this._$Em=t,null==r?this.removeAttribute(e):this.setAttribute(e,r),this._$Em=null;}}_$AK(t,s){const i=this.constructor,e=i._$Eh.get(t);if(void 0!==e&&this._$Em!==e){const t=i.getPropertyOptions(e),r="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==t.converter?.fromAttribute?t.converter:u$1;this._$Em=e,this[e]=r.fromAttribute(s,t.type),this._$Em=null;}}requestUpdate(t,s,i,e=!1,r){if(void 0!==t){if(i??=this.constructor.getPropertyOptions(t),!(i.hasChanged??f$3)(e?r:this[t],s))return;this.C(t,s,i);}!1===this.isUpdatePending&&(this._$Eg=this._$EP());}C(t,s,i){this._$AL.has(t)||this._$AL.set(t,s),!0===i.reflect&&this._$Em!==t&&(this._$Ej??=new Set).add(t);}async _$EP(){this.isUpdatePending=!0;try{await this._$Eg;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this._$Ep){for(const[t,s]of this._$Ep)this[t]=s;this._$Ep=void 0;}const t=this.constructor.elementProperties;if(t.size>0)for(const[s,i]of t)!0!==i.wrapped||this._$AL.has(s)||void 0===this[s]||this.C(s,this[s],i);}let t=!1;const s=this._$AL;try{t=this.shouldUpdate(s),t?(this.willUpdate(s),this._$ES?.forEach((t=>t.hostUpdate?.())),this.update(s)):this._$ET();}catch(s){throw t=!1,this._$ET(),s}t&&this._$AE(s);}willUpdate(t){}_$AE(t){this._$ES?.forEach((t=>t.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$ET(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$Eg}shouldUpdate(t){return !0}update(t){this._$Ej&&=this._$Ej.forEach((t=>this._$EO(t,this[t]))),this._$ET();}updated(t){}firstUpdated(t){}}b.elementStyles=[],b.shadowRootOptions={mode:"open"},b[d$1("elementProperties")]=new Map,b[d$1("finalized")]=new Map,p$1?.({ReactiveElement:b}),(a$1.reactiveElementVersions??=[]).push("2.0.0");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1=globalThis,i$1=t$1.trustedTypes,s$2=i$1?i$1.createPolicy("lit-html",{createHTML:t=>t}):void 0,e$1="$lit$",h$1=`lit$${(Math.random()+"").slice(9)}$`,o$1="?"+h$1,n$1=`<${o$1}>`,r$2=document,l=()=>r$2.createComment(""),c$1=t=>null===t||"object"!=typeof t&&"function"!=typeof t,a=Array.isArray,u=t=>a(t)||"function"==typeof t?.[Symbol.iterator],d="[ \t\n\f\r]",f$2=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v=/-->/g,_=/>/g,m=RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),p=/'/g,g=/"/g,$=/^(?:script|style|textarea|title)$/i,y=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=y(1),w=Symbol.for("lit-noChange"),T=Symbol.for("lit-nothing"),A=new WeakMap,E=r$2.createTreeWalker(r$2,129);function C(t,i){if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==s$2?s$2.createHTML(i):i}const P=(t,i)=>{const s=t.length-1,o=[];let r,l=2===i?"<svg>":"",c=f$2;for(let i=0;i<s;i++){const s=t[i];let a,u,d=-1,y=0;for(;y<s.length&&(c.lastIndex=y,u=c.exec(s),null!==u);)y=c.lastIndex,c===f$2?"!--"===u[1]?c=v:void 0!==u[1]?c=_:void 0!==u[2]?($.test(u[2])&&(r=RegExp("</"+u[2],"g")),c=m):void 0!==u[3]&&(c=m):c===m?">"===u[0]?(c=r??f$2,d=-1):void 0===u[1]?d=-2:(d=c.lastIndex-u[2].length,a=u[1],c=void 0===u[3]?m:'"'===u[3]?g:p):c===g||c===p?c=m:c===v||c===_?c=f$2:(c=m,r=void 0);const x=c===m&&t[i+1].startsWith("/>")?" ":"";l+=c===f$2?s+n$1:d>=0?(o.push(a),s.slice(0,d)+e$1+s.slice(d)+h$1+x):s+h$1+(-2===d?i:x);}return [C(t,l+(t[s]||"<?>")+(2===i?"</svg>":"")),o]};class V{constructor({strings:t,_$litType$:s},n){let r;this.parts=[];let c=0,a=0;const u=t.length-1,d=this.parts,[f,v]=P(t,s);if(this.el=V.createElement(f,n),E.currentNode=this.el.content,2===s){const t=this.el.content.firstChild;t.replaceWith(...t.childNodes);}for(;null!==(r=E.nextNode())&&d.length<u;){if(1===r.nodeType){if(r.hasAttributes())for(const t of r.getAttributeNames())if(t.endsWith(e$1)){const i=v[a++],s=r.getAttribute(t).split(h$1),e=/([.?@])?(.*)/.exec(i);d.push({type:1,index:c,name:e[2],strings:s,ctor:"."===e[1]?k:"?"===e[1]?H:"@"===e[1]?I:R}),r.removeAttribute(t);}else t.startsWith(h$1)&&(d.push({type:6,index:c}),r.removeAttribute(t));if($.test(r.tagName)){const t=r.textContent.split(h$1),s=t.length-1;if(s>0){r.textContent=i$1?i$1.emptyScript:"";for(let i=0;i<s;i++)r.append(t[i],l()),E.nextNode(),d.push({type:2,index:++c});r.append(t[s],l());}}}else if(8===r.nodeType)if(r.data===o$1)d.push({type:2,index:c});else {let t=-1;for(;-1!==(t=r.data.indexOf(h$1,t+1));)d.push({type:7,index:c}),t+=h$1.length-1;}c++;}}static createElement(t,i){const s=r$2.createElement("template");return s.innerHTML=t,s}}function N(t,i,s=t,e){if(i===w)return i;let h=void 0!==e?s._$Co?.[e]:s._$Cl;const o=c$1(i)?void 0:i._$litDirective$;return h?.constructor!==o&&(h?._$AO?.(!1),void 0===o?h=void 0:(h=new o(t),h._$AT(t,s,e)),void 0!==e?(s._$Co??=[])[e]=h:s._$Cl=h),void 0!==h&&(i=N(t,h._$AS(t,i.values),h,e)),i}class S{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){const{el:{content:i},parts:s}=this._$AD,e=(t?.creationScope??r$2).importNode(i,!0);E.currentNode=e;let h=E.nextNode(),o=0,n=0,l=s[0];for(;void 0!==l;){if(o===l.index){let i;2===l.type?i=new M(h,h.nextSibling,this,t):1===l.type?i=new l.ctor(h,l.name,l.strings,this,t):6===l.type&&(i=new L(h,this,t)),this._$AV.push(i),l=s[++n];}o!==l?.index&&(h=E.nextNode(),o++);}return E.currentNode=r$2,e}p(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class M{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(t,i,s,e){this.type=2,this._$AH=T,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cv=e?.isConnected??!0;}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t?.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=N(this,t,i),c$1(t)?t===T||null==t||""===t?(this._$AH!==T&&this._$AR(),this._$AH=T):t!==this._$AH&&t!==w&&this._(t):void 0!==t._$litType$?this.g(t):void 0!==t.nodeType?this.$(t):u(t)?this.T(t):this._(t);}k(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}$(t){this._$AH!==t&&(this._$AR(),this._$AH=this.k(t));}_(t){this._$AH!==T&&c$1(this._$AH)?this._$AA.nextSibling.data=t:this.$(r$2.createTextNode(t)),this._$AH=t;}g(t){const{values:i,_$litType$:s}=t,e="number"==typeof s?this._$AC(t):(void 0===s.el&&(s.el=V.createElement(C(s.h,s.h[0]),this.options)),s);if(this._$AH?._$AD===e)this._$AH.p(i);else {const t=new S(e,this),s=t.u(this.options);t.p(i),this.$(s),this._$AH=t;}}_$AC(t){let i=A.get(t.strings);return void 0===i&&A.set(t.strings,i=new V(t)),i}T(t){a(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const h of t)e===i.length?i.push(s=new M(this.k(l()),this.k(l()),this,this.options)):s=i[e],s._$AI(h),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){for(this._$AP?.(!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){void 0===this._$AM&&(this._$Cv=t,this._$AP?.(t));}}class R{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(t,i,s,e,h){this.type=1,this._$AH=T,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=h,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=T;}_$AI(t,i=this,s,e){const h=this.strings;let o=!1;if(void 0===h)t=N(this,t,i,0),o=!c$1(t)||t!==this._$AH&&t!==w,o&&(this._$AH=t);else {const e=t;let n,r;for(t=h[0],n=0;n<h.length-1;n++)r=N(this,e[s+n],i,n),r===w&&(r=this._$AH[n]),o||=!c$1(r)||r!==this._$AH[n],r===T?t=T:t!==T&&(t+=(r??"")+h[n+1]),this._$AH[n]=r;}o&&!e&&this.O(t);}O(t){t===T?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,t??"");}}class k extends R{constructor(){super(...arguments),this.type=3;}O(t){this.element[this.name]=t===T?void 0:t;}}class H extends R{constructor(){super(...arguments),this.type=4;}O(t){this.element.toggleAttribute(this.name,!!t&&t!==T);}}class I extends R{constructor(t,i,s,e,h){super(t,i,s,e,h),this.type=5;}_$AI(t,i=this){if((t=N(this,t,i,0)??T)===w)return;const s=this._$AH,e=t===T&&s!==T||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,h=t!==T&&(s===T||e);e&&this.element.removeEventListener(this.name,this,s),h&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){"function"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,t):this._$AH.handleEvent(t);}}class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){N(this,t);}}const Z=t$1.litHtmlPolyfillSupport;Z?.(V,M),(t$1.litHtmlVersions??=[]).push("3.1.0");const j=(t,i,s)=>{const e=s?.renderBefore??i;let h=e._$litPart$;if(void 0===h){const t=s?.renderBefore??null;e._$litPart$=h=new M(i.insertBefore(l(),t),t,void 0,s??{});}return h._$AI(t),h};

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */let s$1 = class s extends b{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0;}createRenderRoot(){const t=super.createRenderRoot();return this.renderOptions.renderBefore??=t.firstChild,t}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=j(i,this.renderRoot,this.renderOptions);}connectedCallback(){super.connectedCallback(),this._$Do?.setConnected(!0);}disconnectedCallback(){super.disconnectedCallback(),this._$Do?.setConnected(!1);}render(){return w}};s$1._$litElement$=!0,s$1[("finalized")]=!0,globalThis.litElementHydrateSupport?.({LitElement:s$1});const r$1=globalThis.litElementPolyfillSupport;r$1?.({LitElement:s$1});(globalThis.litElementVersions??=[]).push("4.0.0");

var __classPrivateFieldSet$j = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$q = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Locker_locked;
class Locker {
    constructor() {
        _Locker_locked.set(this, false);
    }
    lock(fn) {
        __classPrivateFieldSet$j(this, _Locker_locked, true, "f");
        const result = fn();
        __classPrivateFieldSet$j(this, _Locker_locked, false, "f");
        return result;
    }
    get locked() {
        return __classPrivateFieldGet$q(this, _Locker_locked, "f");
    }
}
_Locker_locked = new WeakMap();

const make_map = () => new Map();
const make_set = () => new Set();

function maptool(map) {
    return new MapTool(map);
}
class MapTool {
    constructor(map) {
        this.map = map;
    }
    grab(key, make) {
        const { map } = this;
        if (map.has(key))
            return map.get(key);
        else {
            const value = make();
            map.set(key, value);
            return value;
        }
    }
}

var __classPrivateFieldGet$p = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$i = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Tracker_tracking;
class Tracker {
    constructor() {
        _Tracker_tracking.set(this, new WeakMap());
    }
    grab_keymap(state) {
        const keymap = maptool(__classPrivateFieldGet$p(this, _Tracker_tracking, "f")).grab(state, make_map);
        return {
            keymap,
            grab_symbolmap(key) {
                return maptool(keymap).grab(key, make_map);
            },
        };
    }
    clear() {
        __classPrivateFieldSet$i(this, _Tracker_tracking, new WeakMap(), "f");
    }
}
_Tracker_tracking = new WeakMap();

var __classPrivateFieldGet$o = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Stopper_map;
class Stopper {
    constructor() {
        _Stopper_map.set(this, new Map);
    }
    stop(symbol) {
        const stop = __classPrivateFieldGet$o(this, _Stopper_map, "f").get(symbol);
        if (stop) {
            __classPrivateFieldGet$o(this, _Stopper_map, "f").delete(symbol);
            stop();
        }
    }
    add(symbol, fun) {
        __classPrivateFieldGet$o(this, _Stopper_map, "f").set(symbol, fun);
    }
}
_Stopper_map = new WeakMap();

var __classPrivateFieldGet$n = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Recorder_recordings;
class Recorder {
    constructor() {
        _Recorder_recordings.set(this, []);
    }
    record(fn) {
        const recording = make_map();
        __classPrivateFieldGet$n(this, _Recorder_recordings, "f").push(recording);
        const payload = fn();
        __classPrivateFieldGet$n(this, _Recorder_recordings, "f").pop();
        return { payload, recording };
    }
    record_that_key_was_accessed(state, key) {
        const recording = __classPrivateFieldGet$n(this, _Recorder_recordings, "f").at(-1);
        if (recording) {
            const keyset = maptool(recording).grab(state, make_set);
            keyset.add(key);
        }
    }
}
_Recorder_recordings = new WeakMap();

class FlatstateError extends Error {
    constructor() {
        super(...arguments);
        this.name = this.constructor.name;
    }
}
class CircularFlatstateError extends FlatstateError {
    constructor(key) {
        super(`forbidden circularity, rejected assignment to "${key}"`);
    }
}
class ReadonlyError extends FlatstateError {
    constructor(key) {
        super(`forbidden assignment to readonly property "${key}"`);
    }
}

function readonly(s) {
    return new Proxy(s, {
        get(target, key) {
            return target[key];
        },
        set(_, key) {
            throw new ReadonlyError(key);
        },
    });
}

function debounce(delay, action) {
    let latestArgs;
    let timeout;
    let waitingQueue = [];
    function reset() {
        latestArgs = [];
        if (timeout)
            clearTimeout(timeout);
        timeout = undefined;
        waitingQueue = [];
    }
    reset();
    return ((...args) => {
        latestArgs = args;
        if (timeout)
            clearTimeout(timeout);
        const promise = new Promise((resolve, reject) => {
            waitingQueue.push({ resolve, reject });
        });
        timeout = setTimeout(() => {
            Promise.resolve()
                .then(() => action(...latestArgs))
                .then(r => {
                for (const { resolve } of waitingQueue)
                    resolve(r);
                reset();
            })
                .catch(err => {
                for (const { reject } of waitingQueue)
                    reject(err);
                reset();
            });
        }, delay);
        return promise;
    });
}

var __classPrivateFieldGet$m = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$h = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Scheduler_queue, _Scheduler_wait, _Scheduler_actuate;
class Scheduler {
    constructor() {
        _Scheduler_queue.set(this, new Map());
        _Scheduler_wait.set(this, Promise.resolve());
        _Scheduler_actuate.set(this, debounce(0, () => {
            const functions = [...__classPrivateFieldGet$m(this, _Scheduler_queue, "f").values()];
            __classPrivateFieldGet$m(this, _Scheduler_queue, "f").clear();
            for (const fun of functions)
                fun();
        }));
    }
    get wait() {
        return __classPrivateFieldGet$m(this, _Scheduler_wait, "f");
    }
    add(symbol, fun) {
        __classPrivateFieldGet$m(this, _Scheduler_queue, "f").set(symbol, fun);
        __classPrivateFieldSet$h(this, _Scheduler_wait, __classPrivateFieldGet$m(this, _Scheduler_actuate, "f").call(this), "f");
    }
}
_Scheduler_queue = new WeakMap(), _Scheduler_wait = new WeakMap(), _Scheduler_actuate = new WeakMap();

function collectivize(state) {
    return function (collector) {
        return () => {
            const s = typeof state === "function"
                ? state()
                : state;
            return collector(s);
        };
    };
}

function save_reaction(symbol, recording, tracker, reaction) {
    const stoppers = [];
    for (const [state, keyset] of recording) {
        const { grab_symbolmap } = tracker.grab_keymap(state);
        for (const key of keyset) {
            const symbolmap = grab_symbolmap(key);
            symbolmap.set(symbol, reaction);
            stoppers.push(() => symbolmap.delete(symbol));
        }
    }
    return () => stoppers.forEach(stop => stop());
}

function proxy_handlers(tracker, recorder, locker, stopper, scheduler) {
    function actuate([symbol, reaction]) {
        if ("lean" in reaction) {
            reaction.actor();
        }
        else {
            const { payload, recording } = recorder.record(reaction.collector);
            stopper.add(symbol, save_reaction(symbol, recording, tracker, reaction));
            if (reaction.responder)
                reaction.responder(payload);
        }
    }
    return {
        get: (state, key) => {
            recorder.record_that_key_was_accessed(state, key);
            return state[key];
        },
        set: (state, key, value) => {
            if (locker.locked)
                throw new CircularFlatstateError(key);
            state[key] = value;
            const reactions = [...tracker.grab_keymap(state).grab_symbolmap(key)];
            for (const entry of reactions) {
                const [symbol] = entry;
                scheduler.add(symbol, () => locker.lock(() => actuate(entry)));
            }
            return true;
        },
    };
}

var __classPrivateFieldGet$l = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Flat_tracker, _Flat_recorder, _Flat_locker, _Flat_stopper, _Flat_scheduler, _Flat_proxy_handlers;
class Flat {
    constructor() {
        _Flat_tracker.set(this, new Tracker());
        _Flat_recorder.set(this, new Recorder());
        _Flat_locker.set(this, new Locker());
        _Flat_stopper.set(this, new Stopper());
        _Flat_scheduler.set(this, new Scheduler());
        _Flat_proxy_handlers.set(this, proxy_handlers(__classPrivateFieldGet$l(this, _Flat_tracker, "f"), __classPrivateFieldGet$l(this, _Flat_recorder, "f"), __classPrivateFieldGet$l(this, _Flat_locker, "f"), __classPrivateFieldGet$l(this, _Flat_stopper, "f"), __classPrivateFieldGet$l(this, _Flat_scheduler, "f")));
    }
    get wait() {
        return __classPrivateFieldGet$l(this, _Flat_scheduler, "f").wait;
    }
    state(state) {
        return new Proxy(state, __classPrivateFieldGet$l(this, _Flat_proxy_handlers, "f"));
    }
    reaction(collector, responder) {
        const symbol = Symbol();
        const { recording } = __classPrivateFieldGet$l(this, _Flat_recorder, "f").record(() => __classPrivateFieldGet$l(this, _Flat_locker, "f").lock(collector));
        __classPrivateFieldGet$l(this, _Flat_stopper, "f").add(symbol, save_reaction(symbol, recording, __classPrivateFieldGet$l(this, _Flat_tracker, "f"), { collector, responder }));
        return () => __classPrivateFieldGet$l(this, _Flat_stopper, "f").stop(symbol);
    }
    lean(actor) {
        const symbol = Symbol();
        return {
            stop: () => __classPrivateFieldGet$l(this, _Flat_stopper, "f").stop(symbol),
            collect: collector => {
                const { payload, recording } = __classPrivateFieldGet$l(this, _Flat_recorder, "f").record(() => __classPrivateFieldGet$l(this, _Flat_locker, "f").lock(collector));
                __classPrivateFieldGet$l(this, _Flat_stopper, "f").add(symbol, save_reaction(symbol, recording, __classPrivateFieldGet$l(this, _Flat_tracker, "f"), { lean: true, actor }));
                return payload;
            },
        };
    }
    clear() {
        __classPrivateFieldGet$l(this, _Flat_tracker, "f").clear();
    }
}
_Flat_tracker = new WeakMap(), _Flat_recorder = new WeakMap(), _Flat_locker = new WeakMap(), _Flat_stopper = new WeakMap(), _Flat_scheduler = new WeakMap(), _Flat_proxy_handlers = new WeakMap();
Flat.readonly = readonly;
Flat.collectivize = collectivize;

var __classPrivateFieldSet$g = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$k = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Slice_options;
class Slice {
    constructor(options) {
        _Slice_options.set(this, void 0);
        __classPrivateFieldSet$g(this, _Slice_options, options, "f");
    }
    get state() {
        return __classPrivateFieldGet$k(this, _Slice_options, "f").getter(__classPrivateFieldGet$k(this, _Slice_options, "f").parent.state);
    }
    transmute(fun) {
        __classPrivateFieldGet$k(this, _Slice_options, "f").parent.transmute(state => {
            const x1 = __classPrivateFieldGet$k(this, _Slice_options, "f").getter(state);
            const x2 = fun(x1);
            const new_state = __classPrivateFieldGet$k(this, _Slice_options, "f").setter(state, x2);
            return new_state;
        });
    }
    slice({ getter, setter }) {
        return new Slice({
            parent: this,
            getter,
            setter,
        });
    }
}
_Slice_options = new WeakMap();

function deepFreeze(obj) {
    if (obj === null || typeof obj !== 'object')
        return obj;
    Object.values(obj).forEach(value => {
        if (typeof value === 'object' && value !== null)
            deepFreeze(value);
    });
    return Object.freeze(obj);
}

var __classPrivateFieldGet$j = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$f = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _StateTree_instances, _StateTree_state, _StateTree_readable, _StateTree_onChange, _StateTree_circularity_lock, _StateTree_make_frozen_clone;
class StateTree {
    constructor(state, onChange = () => { }) {
        _StateTree_instances.add(this);
        _StateTree_state.set(this, void 0);
        _StateTree_readable.set(this, void 0);
        _StateTree_onChange.set(this, void 0);
        _StateTree_circularity_lock.set(this, false);
        __classPrivateFieldSet$f(this, _StateTree_state, structuredClone(state), "f");
        __classPrivateFieldSet$f(this, _StateTree_readable, __classPrivateFieldGet$j(this, _StateTree_instances, "m", _StateTree_make_frozen_clone).call(this), "f");
        __classPrivateFieldSet$f(this, _StateTree_onChange, onChange, "f");
    }
    get state() {
        return __classPrivateFieldGet$j(this, _StateTree_readable, "f");
    }
    transmute(fun) {
        if (__classPrivateFieldGet$j(this, _StateTree_circularity_lock, "f"))
            throw new Error("circular error");
        __classPrivateFieldSet$f(this, _StateTree_circularity_lock, true, "f");
        __classPrivateFieldSet$f(this, _StateTree_state, fun(structuredClone(__classPrivateFieldGet$j(this, _StateTree_state, "f"))), "f");
        __classPrivateFieldSet$f(this, _StateTree_readable, __classPrivateFieldGet$j(this, _StateTree_instances, "m", _StateTree_make_frozen_clone).call(this), "f");
        __classPrivateFieldGet$j(this, _StateTree_onChange, "f").call(this);
        __classPrivateFieldSet$f(this, _StateTree_circularity_lock, false, "f");
    }
    slice({ getter, setter }) {
        return new Slice({
            parent: this,
            getter,
            setter,
        });
    }
}
_StateTree_state = new WeakMap(), _StateTree_readable = new WeakMap(), _StateTree_onChange = new WeakMap(), _StateTree_circularity_lock = new WeakMap(), _StateTree_instances = new WeakSet(), _StateTree_make_frozen_clone = function _StateTree_make_frozen_clone() {
    return deepFreeze(structuredClone(__classPrivateFieldGet$j(this, _StateTree_state, "f")));
};

const deepEqual = (alpha, bravo) => {
    if (alpha === bravo)
        return true;
    if (typeof alpha !== 'object' || alpha === null || typeof bravo !== 'object' || bravo === null)
        return false;
    const keys1 = Object.keys(alpha);
    const keys2 = Object.keys(bravo);
    if (keys1.length !== keys2.length)
        return false;
    for (const key of keys1) {
        if (!keys2.includes(key))
            return false;
        if (!deepEqual(alpha[key], bravo[key]))
            return false;
    }
    return true;
};

var __classPrivateFieldSet$e = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$i = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _WatchTower_signals, _WatchTower_computeds, _WatchTower_listeners, _WatchTower_memory;
class WatchTower {
    constructor(signals) {
        _WatchTower_signals.set(this, void 0);
        _WatchTower_computeds.set(this, new Set());
        _WatchTower_listeners.set(this, new Set());
        _WatchTower_memory.set(this, new Map());
        __classPrivateFieldSet$e(this, _WatchTower_signals, signals, "f");
    }
    dispatch() {
        for (const computed of __classPrivateFieldGet$i(this, _WatchTower_computeds, "f"))
            computed();
        for (const listener of __classPrivateFieldGet$i(this, _WatchTower_listeners, "f"))
            listener();
    }
    computed(fun) {
        const box = __classPrivateFieldGet$i(this, _WatchTower_signals, "f").signal(fun());
        __classPrivateFieldGet$i(this, _WatchTower_computeds, "f").add(() => { box.value = fun(); });
        return box;
    }
    track(collector, responder) {
        let first = true;
        const listener = () => {
            const current = collector();
            const previous = __classPrivateFieldGet$i(this, _WatchTower_memory, "f").get(collector);
            if (first || !deepEqual(current, previous)) {
                first = false;
                __classPrivateFieldGet$i(this, _WatchTower_memory, "f").set(collector, current);
                responder(current);
            }
        };
        listener();
        __classPrivateFieldGet$i(this, _WatchTower_listeners, "f").add(listener);
        return collector();
    }
    stateTree(state) {
        return new StateTree(state, () => this.dispatch());
    }
}
_WatchTower_signals = new WeakMap(), _WatchTower_computeds = new WeakMap(), _WatchTower_listeners = new WeakMap(), _WatchTower_memory = new WeakMap();

var __classPrivateFieldGet$h = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Reactor_wait;
class Reactor {
    constructor(flat, signals) {
        this.flat = flat;
        this.signals = signals;
        _Reactor_wait.set(this, Promise.resolve());
    }
    get wait() {
        return Promise
            .all([this.flat.wait, this.signals.wait])
            .then(() => __classPrivateFieldGet$h(this, _Reactor_wait, "f"));
    }
    reaction(collector, responder) {
        const actuate = responder
            ? () => responder(collect())
            : () => collect();
        const lean = this.lean(actuate);
        const collect = () => lean.collect(collector);
        collect();
        return lean.stop;
    }
    lean(actor) {
        const lean1 = this.flat.lean(actor);
        const lean2 = this.signals.lean(actor);
        return {
            stop() {
                lean1.stop();
                lean2.stop();
            },
            collect(collector) {
                return lean1.collect(() => lean2.collect(collector));
            },
        };
    }
}
_Reactor_wait = new WeakMap();

var ob;
(function (ob) {
    ob.map = (o, transform) => (Object.fromEntries(Object.entries(o)
        .map(([key, value]) => [key, transform(value, key)])));
    ob.filter = (o, judge) => Object.fromEntries(Object.entries(o)
        .filter(([key, value]) => judge(value, key)));
    (function (pipe) {
        pipe.map = (transform) => ((o) => ob.map(o, transform));
        pipe.filter = (transform) => ((o) => ob.filter(o, transform));
    })(ob.pipe || (ob.pipe = {}));
})(ob || (ob = {}));

const accessed = Symbol();

class SignalCircularError extends Error {
    constructor() {
        super(...arguments);
        this.name = this.constructor.name;
    }
}

var __classPrivateFieldSet$d = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$g = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Signal_value, _Signal_lock, _Signal_wait, _Signal_listeners, _Signal_invoke_listeners, _a;
class Signal {
    constructor(v) {
        _Signal_value.set(this, void 0);
        _Signal_lock.set(this, false);
        _Signal_wait.set(this, void 0);
        _Signal_listeners.set(this, new Set());
        this[_a] = false;
        _Signal_invoke_listeners.set(this, debounce(0, () => {
            const value = __classPrivateFieldGet$g(this, _Signal_value, "f");
            __classPrivateFieldSet$d(this, _Signal_lock, true, "f");
            for (const listener of __classPrivateFieldGet$g(this, _Signal_listeners, "f"))
                listener(value);
            __classPrivateFieldSet$d(this, _Signal_lock, false, "f");
            return value;
        }));
        __classPrivateFieldSet$d(this, _Signal_value, v, "f");
        __classPrivateFieldSet$d(this, _Signal_wait, Promise.resolve(v), "f");
    }
    subscribe(listener) {
        __classPrivateFieldGet$g(this, _Signal_listeners, "f").add(listener);
        return () => void __classPrivateFieldGet$g(this, _Signal_listeners, "f").delete(listener);
    }
    once(listener) {
        const actual_listener = v => {
            listener(v);
            __classPrivateFieldGet$g(this, _Signal_listeners, "f").delete(actual_listener);
        };
        __classPrivateFieldGet$g(this, _Signal_listeners, "f").add(actual_listener);
        return () => void __classPrivateFieldGet$g(this, _Signal_listeners, "f").delete(actual_listener);
    }
    clear() {
        return __classPrivateFieldGet$g(this, _Signal_listeners, "f").clear();
    }
    async publish() {
        __classPrivateFieldSet$d(this, _Signal_wait, __classPrivateFieldGet$g(this, _Signal_invoke_listeners, "f").call(this), "f");
        await __classPrivateFieldGet$g(this, _Signal_wait, "f");
    }
    get wait() {
        return __classPrivateFieldGet$g(this, _Signal_wait, "f");
    }
    get value() {
        this[accessed] = true;
        return __classPrivateFieldGet$g(this, _Signal_value, "f");
    }
    set value(s) {
        if (__classPrivateFieldGet$g(this, _Signal_lock, "f"))
            throw new SignalCircularError("you can't set a signal in a signal's subscription listener (infinite loop forbidden)");
        __classPrivateFieldSet$d(this, _Signal_value, s, "f");
        this.publish();
    }
}
_Signal_value = new WeakMap(), _Signal_lock = new WeakMap(), _Signal_wait = new WeakMap(), _Signal_listeners = new WeakMap(), _Signal_invoke_listeners = new WeakMap(), _a = accessed;

const JsError = Error;
var Op;
(function (Op) {
    Op.loading = () => ({ mode: "loading" });
    Op.error = (reason) => ({ mode: "error", reason });
    Op.ready = (payload) => ({ mode: "ready", payload });
    Op.is = Object.freeze({
        loading: (op) => op.mode === "loading",
        error: (op) => op.mode === "error",
        ready: (op) => op.mode === "ready",
    });
    function payload(op) {
        return (op.mode === "ready")
            ? op.payload
            : undefined;
    }
    Op.payload = payload;
    function select(op, choices) {
        switch (op.mode) {
            case "loading":
                return choices.loading();
            case "error":
                return choices.error(op.reason);
            case "ready":
                return choices.ready(op.payload);
            default:
                console.error("op", op);
                throw new JsError("invalid op mode");
        }
    }
    Op.select = select;
    async function run(set_op, operation) {
        set_op(Op.loading());
        try {
            const payload = await operation();
            set_op(Op.ready(payload));
            return payload;
        }
        catch (err) {
            const reason = (err instanceof JsError)
                ? err.message
                : (typeof err === "string")
                    ? err
                    : "error";
            set_op(Op.error(reason));
        }
    }
    Op.run = run;
    function morph(op, transmute) {
        return select(op, {
            loading: () => Op.loading(),
            error: reason => Op.error(reason),
            ready: a => Op.ready(transmute(a)),
        });
    }
    Op.morph = morph;
})(Op || (Op = {}));

class OpSignal extends Signal {
    constructor() {
        super(Op.loading());
    }
    async run(operation) {
        return Op.run(op => this.value = op, operation);
    }
    setLoading() {
        this.value = Op.loading();
    }
    setError(reason) {
        this.value = Op.error(reason);
    }
    setReady(payload) {
        this.value = Op.ready(payload);
    }
    get loading() {
        return Op.is.loading(this.value);
    }
    get error() {
        return Op.is.error(this.value);
    }
    get ready() {
        return Op.is.ready(this.value);
    }
    get payload() {
        return Op.payload(this.value);
    }
    select(choices) {
        return Op.select(this.value, choices);
    }
}

var __classPrivateFieldSet$c = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$f = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SignalTracker_instances, _SignalTracker_active, _SignalTracker_all_signals, _SignalTracker_waiters, _SignalTracker_relevant_signals, _SignalTracker_stoppers, _SignalTracker_actuate, _SignalTracker_reset_all_signals_accessed_indicator, _SignalTracker_signals_that_should_be_tracked_get;
class SignalTracker {
    constructor({ all_signals, waiters, }) {
        _SignalTracker_instances.add(this);
        _SignalTracker_active.set(this, true);
        _SignalTracker_all_signals.set(this, void 0);
        _SignalTracker_waiters.set(this, void 0);
        _SignalTracker_relevant_signals.set(this, new Set());
        _SignalTracker_stoppers.set(this, new Set());
        _SignalTracker_actuate.set(this, debounce(0, (track) => {
            if (__classPrivateFieldGet$f(this, _SignalTracker_active, "f")) {
                if ("lean" in track)
                    track.actor();
                else {
                    const { payload, recording } = this.observe(track.collector);
                    this.add_listeners(track, recording);
                    if (track.responder)
                        track.responder(payload);
                }
            }
        }));
        __classPrivateFieldSet$c(this, _SignalTracker_all_signals, all_signals, "f");
        __classPrivateFieldSet$c(this, _SignalTracker_waiters, waiters, "f");
    }
    observe(collector) {
        __classPrivateFieldGet$f(this, _SignalTracker_instances, "m", _SignalTracker_reset_all_signals_accessed_indicator).call(this);
        const payload = collector();
        return {
            payload,
            recording: __classPrivateFieldGet$f(this, _SignalTracker_instances, "a", _SignalTracker_signals_that_should_be_tracked_get),
        };
    }
    add_listeners(track, recording) {
        for (const signal of recording) {
            __classPrivateFieldGet$f(this, _SignalTracker_relevant_signals, "f").add(signal);
            __classPrivateFieldGet$f(this, _SignalTracker_stoppers, "f").add(signal.subscribe(() => __classPrivateFieldGet$f(this, _SignalTracker_waiters, "f").add(__classPrivateFieldGet$f(this, _SignalTracker_actuate, "f").call(this, track))));
        }
    }
    shutdown() {
        __classPrivateFieldSet$c(this, _SignalTracker_active, false, "f");
        __classPrivateFieldGet$f(this, _SignalTracker_stoppers, "f").forEach(stop => stop());
    }
}
_SignalTracker_active = new WeakMap(), _SignalTracker_all_signals = new WeakMap(), _SignalTracker_waiters = new WeakMap(), _SignalTracker_relevant_signals = new WeakMap(), _SignalTracker_stoppers = new WeakMap(), _SignalTracker_actuate = new WeakMap(), _SignalTracker_instances = new WeakSet(), _SignalTracker_reset_all_signals_accessed_indicator = function _SignalTracker_reset_all_signals_accessed_indicator() {
    for (const signal of __classPrivateFieldGet$f(this, _SignalTracker_all_signals, "f"))
        signal[accessed] = false;
}, _SignalTracker_signals_that_should_be_tracked_get = function _SignalTracker_signals_that_should_be_tracked_get() {
    return [...__classPrivateFieldGet$f(this, _SignalTracker_all_signals, "f")].filter(signal => (signal[accessed] &&
        !__classPrivateFieldGet$f(this, _SignalTracker_relevant_signals, "f").has(signal)));
};

var __classPrivateFieldGet$e = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SignalTower_signals, _SignalTower_waiters;
class SignalTower {
    constructor() {
        // TODO wrap all signals in WeakRef, to promote garbage collection?
        _SignalTower_signals.set(this, new Set());
        _SignalTower_waiters.set(this, new Set());
    }
    signal(value) {
        const signal = new Signal(value);
        __classPrivateFieldGet$e(this, _SignalTower_signals, "f").add(signal);
        return signal;
    }
    computed(fun) {
        const signal = this.signal(fun());
        this.reaction(() => { signal.value = fun(); });
        return signal;
    }
    op() {
        const signal = new OpSignal();
        __classPrivateFieldGet$e(this, _SignalTower_signals, "f").add(signal);
        return signal;
    }
    many(states) {
        return (ob.map(states, state => this.signal(state)));
    }
    reaction(collector, responder) {
        const tracker = new SignalTracker({
            waiters: __classPrivateFieldGet$e(this, _SignalTower_waiters, "f"),
            all_signals: __classPrivateFieldGet$e(this, _SignalTower_signals, "f"),
        });
        const track = { collector, responder };
        const { recording } = tracker.observe(track.collector);
        tracker.add_listeners(track, recording);
        return () => tracker.shutdown();
    }
    lean(actor) {
        const tracker = new SignalTracker({
            waiters: __classPrivateFieldGet$e(this, _SignalTower_waiters, "f"),
            all_signals: __classPrivateFieldGet$e(this, _SignalTower_signals, "f"),
        });
        const track = { lean: true, actor };
        return {
            stop: () => tracker.shutdown(),
            collect: collector => {
                const { payload, recording } = tracker.observe(collector);
                tracker.add_listeners(track, recording);
                return payload;
            },
        };
    }
    get wait() {
        return Promise.all([...__classPrivateFieldGet$e(this, _SignalTower_signals, "f")].map(s => s.wait))
            .then(() => Promise.all([...__classPrivateFieldGet$e(this, _SignalTower_waiters, "f")]))
            .then(() => { __classPrivateFieldGet$e(this, _SignalTower_waiters, "f").clear(); });
    }
}
_SignalTower_signals = new WeakMap(), _SignalTower_waiters = new WeakMap();

const flat = new Flat();
const signals = new SignalTower();
const watch = new WatchTower(signals);
flat.state.bind(flat);
signals.signal.bind(signals);
const reactor = new Reactor(flat, signals);

var __classPrivateFieldGet$d = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
function mixinSetups(Base) {
    var _setups, _setdowns, _a;
    return _a = class extends Base {
            constructor() {
                super(...arguments);
                _setups.set(this, new Set()
                    .add(() => this.setup()));
                _setdowns.set(this, new Set());
            }
            register_setup(setup) {
                __classPrivateFieldGet$d(this, _setups, "f").add(setup);
            }
            setup() {
                return () => { };
            }
            connectedCallback() {
                for (const setup of __classPrivateFieldGet$d(this, _setups, "f"))
                    __classPrivateFieldGet$d(this, _setdowns, "f").add(setup());
            }
            disconnectedCallback() {
                for (const setdown of __classPrivateFieldGet$d(this, _setdowns, "f"))
                    setdown();
                __classPrivateFieldGet$d(this, _setdowns, "f").clear();
            }
        },
        _setups = new WeakMap(),
        _setdowns = new WeakMap(),
        _a;
}

class MetallicElement extends mixinSetups(HTMLElement) {
}

function explode_promise() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });
    return { promise, resolve, reject };
}

function finalize_styles(styles) {
    const elementStyles = [];
    if (Array.isArray(styles)) {
        const set = new Set(styles.flat(Infinity).reverse());
        for (const s of set)
            elementStyles.unshift(c$3(s));
    }
    else if (styles !== undefined)
        elementStyles.push(c$3(styles));
    return elementStyles;
}

function apply_styles_to_shadow(shadow, styles) {
    S$1(shadow, finalize_styles(styles));
}

var __classPrivateFieldSet$b = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$c = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GoldElement_root, _GoldElement_init, _GoldElement_wait, _GoldElement_render_debounced;
class GoldElement extends MetallicElement {
    static get styles() { return undefined; }
    init() { }
    constructor() {
        super();
        _GoldElement_root.set(this, void 0);
        _GoldElement_init.set(this, explode_promise());
        _GoldElement_wait.set(this, __classPrivateFieldGet$c(this, _GoldElement_init, "f").promise);
        _GoldElement_render_debounced.set(this, debounce(0, () => {
            const root = __classPrivateFieldGet$c(this, _GoldElement_root, "f");
            const template = this.render();
            if (template)
                j(template, root, { host: this });
        }));
        __classPrivateFieldSet$b(this, _GoldElement_root, this.attachShadow({ mode: "open" }), "f");
        const C = this.constructor;
        apply_styles_to_shadow(__classPrivateFieldGet$c(this, _GoldElement_root, "f"), C.styles);
        this.init();
    }
    get root() {
        return __classPrivateFieldGet$c(this, _GoldElement_root, "f");
    }
    get updateComplete() {
        return __classPrivateFieldGet$c(this, _GoldElement_wait, "f").then(() => true);
    }
    render() { }
    async requestUpdate() {
        const promise = __classPrivateFieldGet$c(this, _GoldElement_render_debounced, "f").call(this);
        if (__classPrivateFieldGet$c(this, _GoldElement_init, "f")) {
            promise.then(__classPrivateFieldGet$c(this, _GoldElement_init, "f").resolve);
            __classPrivateFieldSet$b(this, _GoldElement_init, undefined, "f");
        }
        __classPrivateFieldSet$b(this, _GoldElement_wait, promise, "f");
        return promise;
    }
    connectedCallback() {
        super.connectedCallback();
        this.requestUpdate();
    }
}
_GoldElement_root = new WeakMap(), _GoldElement_init = new WeakMap(), _GoldElement_wait = new WeakMap(), _GoldElement_render_debounced = new WeakMap();

var __classPrivateFieldGet$b = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SlateGold_state;
class SlateGold extends GoldElement {
    constructor() {
        super(...arguments);
        _SlateGold_state.set(this, flat.state({
            count: 0,
        }));
    }
    static get styles() { return i$3 `span {color: orange}`; }
    render() {
        return x `
			<span>${__classPrivateFieldGet$b(this, _SlateGold_state, "f").count}</span>
			<button @click=${() => __classPrivateFieldGet$b(this, _SlateGold_state, "f").count++}>gold</button>
		`;
    }
}
_SlateGold_state = new WeakMap();

var __classPrivateFieldSet$a = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$a = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Shell_context;
class Shell {
    constructor(context) {
        _Shell_context.set(this, void 0);
        __classPrivateFieldSet$a(this, _Shell_context, context, "f");
    }
    get context() {
        if (__classPrivateFieldGet$a(this, _Shell_context, "f"))
            return __classPrivateFieldGet$a(this, _Shell_context, "f");
        else
            throw new Error("slate.context was not set, but it's necessary");
    }
    set context(context) {
        __classPrivateFieldSet$a(this, _Shell_context, context, "f");
    }
}
_Shell_context = new WeakMap();

var __classPrivateFieldGet$9 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$9 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var mixin;
(function (mixin) {
    function css(...newStyles) {
        return function (Base) {
            return class extends Base {
                static get styles() {
                    return combineStyles(Base.styles, newStyles);
                }
            };
        };
    }
    mixin.css = css;
    function css_deferred(getNewStyles) {
        return function (Base) {
            return class extends Base {
                static get styles() {
                    return combineStyles(Base.styles, getNewStyles());
                }
            };
        };
    }
    mixin.css_deferred = css_deferred;
    function signals(signals) {
        return function (Base) {
            var _lean, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _lean.set(this, null);
                    }
                    render() {
                        var _b;
                        return (_b = __classPrivateFieldGet$9(this, _lean, "f")) === null || _b === void 0 ? void 0 : _b.collect(() => super.render());
                    }
                    connectedCallback() {
                        super.connectedCallback();
                        __classPrivateFieldSet$9(this, _lean, signals.lean(() => this.requestUpdate()), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        if (__classPrivateFieldGet$9(this, _lean, "f")) {
                            __classPrivateFieldGet$9(this, _lean, "f").stop();
                            __classPrivateFieldSet$9(this, _lean, null, "f");
                        }
                    }
                },
                _lean = new WeakMap(),
                _a;
        };
    }
    mixin.signals = signals;
    function flat(flat) {
        return function (Base) {
            var _lean_1, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _lean_1.set(this, null);
                    }
                    render() {
                        var _b;
                        return (_b = __classPrivateFieldGet$9(this, _lean_1, "f")) === null || _b === void 0 ? void 0 : _b.collect(() => super.render());
                    }
                    connectedCallback() {
                        super.connectedCallback();
                        __classPrivateFieldSet$9(this, _lean_1, flat.lean(() => this.requestUpdate()), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        if (__classPrivateFieldGet$9(this, _lean_1, "f")) {
                            __classPrivateFieldGet$9(this, _lean_1, "f").stop();
                            __classPrivateFieldSet$9(this, _lean_1, null, "f");
                        }
                    }
                },
                _lean_1 = new WeakMap(),
                _a;
        };
    }
    mixin.flat = flat;
    function reactor$1(r = reactor) {
        return function (Base) {
            var _lean_2, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _lean_2.set(this, null);
                    }
                    render() {
                        var _b;
                        return (_b = __classPrivateFieldGet$9(this, _lean_2, "f")) === null || _b === void 0 ? void 0 : _b.collect(() => super.render());
                    }
                    connectedCallback() {
                        super.connectedCallback();
                        __classPrivateFieldSet$9(this, _lean_2, r.lean(() => this.requestUpdate()), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        if (__classPrivateFieldGet$9(this, _lean_2, "f")) {
                            __classPrivateFieldGet$9(this, _lean_2, "f").stop();
                            __classPrivateFieldSet$9(this, _lean_2, null, "f");
                        }
                    }
                },
                _lean_2 = new WeakMap(),
                _a;
        };
    }
    mixin.reactor = reactor$1;
})(mixin || (mixin = {}));
function arrayize(item) {
    return [item].flat().filter(i => !!i);
}
const notUndefined = (x) => x !== undefined;
function combineStyles(parentStyles, newStyles) {
    var _a;
    const styles = [
        ...((_a = arrayize(parentStyles)) !== null && _a !== void 0 ? _a : []),
        ...arrayize(newStyles),
    ];
    return styles
        .flat()
        .filter(notUndefined);
}

var __classPrivateFieldSet$8 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$8 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Pipe_input;
class Pipe {
    static with(input) {
        return new this(input);
    }
    constructor(input) {
        _Pipe_input.set(this, void 0);
        __classPrivateFieldSet$8(this, _Pipe_input, input, "f");
    }
    to(fun) {
        return new Pipe(fun(__classPrivateFieldGet$8(this, _Pipe_input, "f")));
    }
    done() {
        return __classPrivateFieldGet$8(this, _Pipe_input, "f");
    }
}
_Pipe_input = new WeakMap();

var apply;
(function (apply) {
    apply.css = ((theme) => ((elements) => (ob.map(elements, Element => mixin.css(theme)(Element)))));
    apply.flat = ((flat) => ((elements) => (ob.map(elements, (Element) => mixin.flat(flat)(Element)))));
    apply.signals = ((signals) => ((elements) => (ob.map(elements, (Element) => mixin.signals(signals)(Element)))));
    apply.reactor = ((r = reactor) => ((elements) => (ob.map(elements, (Element) => mixin.reactor(r)(Element)))));
    apply.context = ((context) => ((elements) => Pipe.with(elements)
        .to(apply.css(context.theme))
        .to(apply.reactor())
        .done()));
})(apply || (apply = {}));

var __classPrivateFieldGet$7 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$7 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Use_context, _Use_rerender, _Use_counter, _Use_setups, _Use_setdowns, _Use_initStarts, _Use_initResults, _Use_initDowns, _Use_states, _Use_preparations, _Use_flatstates, _Use_signals, _Use_watches, _Counter_value;
class Use {
    static wrap(use, fun) {
        return ((...args) => {
            __classPrivateFieldGet$7(use, _Use_counter, "f").reset();
            return fun(...args);
        });
    }
    static disconnect(use) {
        // cleanup setups
        for (const down of __classPrivateFieldGet$7(use, _Use_setdowns, "f"))
            down();
        __classPrivateFieldGet$7(use, _Use_setdowns, "f").clear();
        // cleanup inits
        for (const down of __classPrivateFieldGet$7(use, _Use_initDowns, "f"))
            down();
        __classPrivateFieldGet$7(use, _Use_initDowns, "f").clear();
        __classPrivateFieldGet$7(use, _Use_initResults, "f").clear();
    }
    static reconnect(use) {
        // call all setups
        for (const up of __classPrivateFieldGet$7(use, _Use_setups, "f").values())
            __classPrivateFieldGet$7(use, _Use_setdowns, "f").add(up());
        // call all inits
        for (const [count, start] of __classPrivateFieldGet$7(use, _Use_initStarts, "f").entries()) {
            const [result, down] = start();
            __classPrivateFieldGet$7(use, _Use_initResults, "f").set(count, result);
            __classPrivateFieldGet$7(use, _Use_initDowns, "f").add(down);
        }
    }
    constructor(rerender, context) {
        _Use_context.set(this, void 0);
        _Use_rerender.set(this, void 0);
        _Use_counter.set(this, new Counter());
        _Use_setups.set(this, new Map());
        _Use_setdowns.set(this, new Set());
        _Use_initStarts.set(this, new Map());
        _Use_initResults.set(this, new Map());
        _Use_initDowns.set(this, new Set());
        _Use_states.set(this, new Map());
        _Use_preparations.set(this, new Map());
        _Use_flatstates.set(this, new Map());
        _Use_signals.set(this, new Map());
        _Use_watches.set(this, new Map());
        __classPrivateFieldSet$7(this, _Use_rerender, rerender, "f");
        __classPrivateFieldSet$7(this, _Use_context, context, "f");
    }
    get context() {
        return __classPrivateFieldGet$7(this, _Use_context, "f");
    }
    rerender() {
        __classPrivateFieldGet$7(this, _Use_rerender, "f").call(this);
    }
    setup(func) {
        const count = __classPrivateFieldGet$7(this, _Use_counter, "f").pull();
        if (!__classPrivateFieldGet$7(this, _Use_setups, "f").has(count)) {
            __classPrivateFieldGet$7(this, _Use_setups, "f").set(count, func);
            __classPrivateFieldGet$7(this, _Use_setdowns, "f").add(func());
        }
    }
    init(func) {
        const count = __classPrivateFieldGet$7(this, _Use_counter, "f").pull();
        if (!__classPrivateFieldGet$7(this, _Use_initStarts, "f").has(count)) {
            __classPrivateFieldGet$7(this, _Use_initStarts, "f").set(count, func);
            const [result, down] = func();
            __classPrivateFieldGet$7(this, _Use_initResults, "f").set(count, result);
            __classPrivateFieldGet$7(this, _Use_initDowns, "f").add(down);
            return result;
        }
        return __classPrivateFieldGet$7(this, _Use_initResults, "f").get(count);
    }
    prepare(prep) {
        const count = __classPrivateFieldGet$7(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet$7(this, _Use_preparations, "f")).grab(count, prep);
    }
    state(init) {
        const count = __classPrivateFieldGet$7(this, _Use_counter, "f").pull();
        const value = maptool(__classPrivateFieldGet$7(this, _Use_states, "f")).grab(count, () => ((typeof init === "function")
            ? init()
            : init));
        const setter = (v) => {
            __classPrivateFieldGet$7(this, _Use_states, "f").set(count, v);
            __classPrivateFieldGet$7(this, _Use_rerender, "f").call(this);
        };
        const getter = () => __classPrivateFieldGet$7(this, _Use_states, "f").get(count);
        return [value, setter, getter];
    }
    flatstate(init) {
        const count = __classPrivateFieldGet$7(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet$7(this, _Use_flatstates, "f")).grab(count, () => (flat.state((typeof init === "function")
            ? init()
            : init)));
    }
    signal(init) {
        const count = __classPrivateFieldGet$7(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet$7(this, _Use_signals, "f")).grab(count, () => (signals.signal((typeof init === "function")
            ? init()
            : init)));
    }
    computed(update) {
        const count = __classPrivateFieldGet$7(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet$7(this, _Use_signals, "f")).grab(count, () => (signals.computed(update)));
    }
    op() {
        const count = __classPrivateFieldGet$7(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet$7(this, _Use_signals, "f")).grab(count, () => signals.op());
    }
    watch(collector) {
        const count = __classPrivateFieldGet$7(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet$7(this, _Use_watches, "f")).grab(count, () => watch.track(collector, data => {
            __classPrivateFieldGet$7(this, _Use_watches, "f").set(count, data);
            __classPrivateFieldGet$7(this, _Use_rerender, "f").call(this);
        }));
    }
}
_Use_context = new WeakMap(), _Use_rerender = new WeakMap(), _Use_counter = new WeakMap(), _Use_setups = new WeakMap(), _Use_setdowns = new WeakMap(), _Use_initStarts = new WeakMap(), _Use_initResults = new WeakMap(), _Use_initDowns = new WeakMap(), _Use_states = new WeakMap(), _Use_preparations = new WeakMap(), _Use_flatstates = new WeakMap(), _Use_signals = new WeakMap(), _Use_watches = new WeakMap();
class Counter {
    constructor() {
        _Counter_value.set(this, 0);
    }
    pull() {
        var _a, _b;
        return __classPrivateFieldSet$7(this, _Counter_value, (_b = __classPrivateFieldGet$7(this, _Counter_value, "f"), _a = _b++, _b), "f"), _a;
    }
    reset() {
        __classPrivateFieldSet$7(this, _Counter_value, 0, "f");
    }
}
_Counter_value = new WeakMap();

var __classPrivateFieldGet$6 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$6 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _UseShadow_element, _UseShadow_shadow;
class UseShadow extends Use {
    get element() { return __classPrivateFieldGet$6(this, _UseShadow_element, "f"); }
    get shadow() { return __classPrivateFieldGet$6(this, _UseShadow_shadow, "f"); }
    constructor(element, shadow, rerender, context) {
        super(rerender, context);
        _UseShadow_element.set(this, void 0);
        _UseShadow_shadow.set(this, void 0);
        __classPrivateFieldSet$6(this, _UseShadow_element, element, "f");
        __classPrivateFieldSet$6(this, _UseShadow_shadow, shadow, "f");
    }
}
_UseShadow_element = new WeakMap(), _UseShadow_shadow = new WeakMap();

function attributes(element, spec) {
    Attributes.on_change(element, () => element.requestUpdate());
    return Attributes.proxy(element, spec);
}
var Attributes;
(function (Attributes) {
    Attributes.proxy = (element, spec) => new Proxy(spec, {
        get: (_target, name) => {
            const type = spec[name];
            const raw = element.getAttribute(name);
            switch (type) {
                case String:
                    return raw !== null && raw !== void 0 ? raw : undefined;
                case Number:
                    return raw !== null
                        ? Number(raw)
                        : undefined;
                case Boolean:
                    return raw !== null;
                default:
                    throw new Error(`invalid attribute type for "${name}"`);
            }
        },
        set: (_target, name, value) => {
            const type = spec[name];
            switch (type) {
                case String: {
                    element.setAttribute(name, value);
                    return true;
                }
                case Number: {
                    element.setAttribute(name, value.toString());
                    return true;
                }
                case Boolean: {
                    if (value)
                        element.setAttribute(name, "");
                    else
                        element.removeAttribute(name);
                    return true;
                }
                default:
                    throw new Error(`invalid attribute type for "${name}"`);
            }
        },
    });
    function on_change(element, handle_change) {
        const observer = new MutationObserver(handle_change);
        observer.observe(element, { attributes: true });
        return () => observer.disconnect();
    }
    Attributes.on_change = on_change;
})(Attributes || (Attributes = {}));

function setup_use_attrs(element) {
    let attrs;
    return function (spec) {
        if (!attrs)
            attrs = attributes(element, spec);
        return attrs;
    };
}

class UseGold extends UseShadow {
    constructor(element, shadow, rerender, context) {
        super(element, shadow, rerender, context);
        this.attrs = setup_use_attrs(element);
    }
}

var __classPrivateFieldGet$5 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$5 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _UseSilver_element;
class UseSilver extends Use {
    get element() { return __classPrivateFieldGet$5(this, _UseSilver_element, "f"); }
    constructor(element, rerender, context) {
        super(rerender, context);
        _UseSilver_element.set(this, void 0);
        __classPrivateFieldSet$5(this, _UseSilver_element, element, "f");
        this.attrs = setup_use_attrs(element);
    }
}
_UseSilver_element = new WeakMap();

class UseCarbon extends UseGold {
}
class UseOxygen extends UseSilver {
}
class UseQuartz extends Use {
}
class UseObsidian extends UseShadow {
}

function setup_reactivity(render, rerender) {
    const lean = reactor.lean(rerender);
    return {
        stop: lean.stop,
        render: (...props) => lean.collect(() => render(...props)),
    };
}

var __classPrivateFieldGet$4 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$4 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
const prepare_carbon = ((shell) => (settings, renderer) => {
    var _use, _rend, _reactivity, _a;
    return _a = class extends GoldElement {
            constructor() {
                super(...arguments);
                _use.set(this, new UseCarbon(this, this.root, () => void this.requestUpdate(), shell.context));
                _rend.set(this, UseCarbon.wrap(__classPrivateFieldGet$4(this, _use, "f"), () => renderer(__classPrivateFieldGet$4(this, _use, "f"))));
                _reactivity.set(this, void 0);
            }
            static get styles() {
                var _b;
                return [
                    shell.context.theme,
                    (_b = settings.styles) !== null && _b !== void 0 ? _b : i$3 ``,
                ];
            }
            render() {
                var _b;
                return (_b = __classPrivateFieldGet$4(this, _reactivity, "f")) === null || _b === void 0 ? void 0 : _b.render();
            }
            connectedCallback() {
                super.connectedCallback();
                UseCarbon.reconnect(__classPrivateFieldGet$4(this, _use, "f"));
                __classPrivateFieldSet$4(this, _reactivity, setup_reactivity(__classPrivateFieldGet$4(this, _rend, "f"), () => void this.requestUpdate()), "f");
            }
            disconnectedCallback() {
                super.disconnectedCallback();
                UseCarbon.disconnect(__classPrivateFieldGet$4(this, _use, "f"));
                if (__classPrivateFieldGet$4(this, _reactivity, "f")) {
                    __classPrivateFieldGet$4(this, _reactivity, "f").stop();
                    __classPrivateFieldSet$4(this, _reactivity, undefined, "f");
                }
            }
        },
        _use = new WeakMap(),
        _rend = new WeakMap(),
        _reactivity = new WeakMap(),
        _a.label = settings.name,
        _a;
});

var __classPrivateFieldGet$3 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$3 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _SilverElement_init, _SilverElement_wait, _SilverElement_render_debounced;
class SilverElement extends MetallicElement {
    init() { }
    constructor() {
        super();
        _SilverElement_init.set(this, explode_promise());
        _SilverElement_wait.set(this, __classPrivateFieldGet$3(this, _SilverElement_init, "f").promise);
        _SilverElement_render_debounced.set(this, debounce(0, () => {
            const template = this.render();
            j(template, this, { host: this });
        }));
        this.init();
    }
    get updateComplete() {
        return __classPrivateFieldGet$3(this, _SilverElement_wait, "f").then(() => true);
    }
    render() { }
    async requestUpdate() {
        const promise = __classPrivateFieldGet$3(this, _SilverElement_render_debounced, "f").call(this);
        if (__classPrivateFieldGet$3(this, _SilverElement_init, "f")) {
            promise.then(__classPrivateFieldGet$3(this, _SilverElement_init, "f").resolve);
            __classPrivateFieldSet$3(this, _SilverElement_init, undefined, "f");
        }
        __classPrivateFieldSet$3(this, _SilverElement_wait, promise, "f");
        return promise;
    }
    connectedCallback() {
        super.connectedCallback();
        this.requestUpdate();
    }
}
_SilverElement_init = new WeakMap(), _SilverElement_wait = new WeakMap(), _SilverElement_render_debounced = new WeakMap();

var __classPrivateFieldGet$2 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$2 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
const prepare_oxygen = ((shell) => (renderer) => {
    var _use, _rend, _reactivity, _a;
    return (_a = class extends SilverElement {
            constructor() {
                super(...arguments);
                _use.set(this, new UseOxygen(this, () => void this.requestUpdate(), shell.context));
                _rend.set(this, UseOxygen.wrap(__classPrivateFieldGet$2(this, _use, "f"), () => renderer(__classPrivateFieldGet$2(this, _use, "f"))));
                _reactivity.set(this, void 0);
            }
            render() {
                var _b;
                return (_b = __classPrivateFieldGet$2(this, _reactivity, "f")) === null || _b === void 0 ? void 0 : _b.render();
            }
            connectedCallback() {
                super.connectedCallback();
                __classPrivateFieldSet$2(this, _reactivity, setup_reactivity(__classPrivateFieldGet$2(this, _rend, "f"), () => void this.requestUpdate()), "f");
                UseOxygen.reconnect(__classPrivateFieldGet$2(this, _use, "f"));
            }
            disconnectedCallback() {
                super.disconnectedCallback();
                if (__classPrivateFieldGet$2(this, _reactivity, "f")) {
                    __classPrivateFieldGet$2(this, _reactivity, "f").stop();
                    __classPrivateFieldSet$2(this, _reactivity, undefined, "f");
                }
                UseOxygen.disconnect(__classPrivateFieldGet$2(this, _use, "f"));
            }
        },
        _use = new WeakMap(),
        _rend = new WeakMap(),
        _reactivity = new WeakMap(),
        _a);
});

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const f$1=o=>void 0===o.strings;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},e=t=>(...e)=>({_$litDirective$:t,values:e});class i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i;}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const s=(i,t)=>{const e=i._$AN;if(void 0===e)return !1;for(const i of e)i._$AO?.(t,!1),s(i,t);return !0},o=i=>{let t,e;do{if(void 0===(t=i._$AM))break;e=t._$AN,e.delete(i),i=t;}while(0===e?.size)},r=i=>{for(let t;t=i._$AM;i=t){let e=t._$AN;if(void 0===e)t._$AN=e=new Set;else if(e.has(i))break;e.add(i),c(t);}};function h(i){void 0!==this._$AN?(o(this),this._$AM=i,r(this)):this._$AM=i;}function n(i,t=!1,e=0){const r=this._$AH,h=this._$AN;if(void 0!==h&&0!==h.size)if(t)if(Array.isArray(r))for(let i=e;i<r.length;i++)s(r[i],!1),o(r[i]);else null!=r&&(s(r,!1),o(r));else s(this,i);}const c=i=>{i.type==t.CHILD&&(i._$AP??=n,i._$AQ??=h);};class f extends i{constructor(){super(...arguments),this._$AN=void 0;}_$AT(i,t,e){super._$AT(i,t,e),r(this),this.isConnected=i._$AU;}_$AO(i,t=!0){i!==this.isConnected&&(this.isConnected=i,i?this.reconnected?.():this.disconnected?.()),t&&(s(this,i),o(this));}setValue(t){if(f$1(this._$Ct))this._$Ct._$AI(t,this);else {const i=[...this._$Ct._$AH];i[this._$Ci]=t,this._$Ct._$AI(i,this,0);}}disconnected(){}reconnected(){}}

var __classPrivateFieldSet$1 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$1 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
const prepare_quartz = ((shell) => (renderer) => {
    var _props, _rerender, _use, _rend, _reactivity, _a;
    return e((_a = class extends f {
            constructor() {
                super(...arguments);
                _props.set(this, void 0);
                _rerender.set(this, debounce(0, () => {
                    if (__classPrivateFieldGet$1(this, _props, "f"))
                        this.setValue(this.render(...__classPrivateFieldGet$1(this, _props, "f")));
                }));
                _use.set(this, new UseQuartz(__classPrivateFieldGet$1(this, _rerender, "f"), shell.context));
                _rend.set(this, UseQuartz.wrap(__classPrivateFieldGet$1(this, _use, "f"), renderer(__classPrivateFieldGet$1(this, _use, "f"))));
                _reactivity.set(this, setup_reactivity(__classPrivateFieldGet$1(this, _rend, "f"), __classPrivateFieldGet$1(this, _rerender, "f")));
            }
            render(...props) {
                var _b;
                __classPrivateFieldSet$1(this, _props, props, "f");
                return (_b = __classPrivateFieldGet$1(this, _reactivity, "f")) === null || _b === void 0 ? void 0 : _b.render(...props);
            }
            reconnected() {
                UseQuartz.reconnect(__classPrivateFieldGet$1(this, _use, "f"));
                __classPrivateFieldSet$1(this, _reactivity, setup_reactivity(__classPrivateFieldGet$1(this, _rend, "f"), __classPrivateFieldGet$1(this, _rerender, "f")), "f");
            }
            disconnected() {
                UseQuartz.disconnect(__classPrivateFieldGet$1(this, _use, "f"));
                if (__classPrivateFieldGet$1(this, _reactivity, "f")) {
                    __classPrivateFieldGet$1(this, _reactivity, "f").stop();
                    __classPrivateFieldSet$1(this, _reactivity, undefined, "f");
                }
            }
        },
        _props = new WeakMap(),
        _rerender = new WeakMap(),
        _use = new WeakMap(),
        _rend = new WeakMap(),
        _reactivity = new WeakMap(),
        _a));
});

function pub() {
    const listeners = new Set();
    function subscribe(listener) {
        listeners.add(listener);
        return () => void listeners.delete(listener);
    }
    subscribe.publish = (x) => {
        for (const listener of listeners)
            listener(x);
    };
    subscribe.clear = () => listeners.clear();
    subscribe.once = (listener) => {
        const actual_listener = (x) => {
            listener(x);
            listeners.delete(actual_listener);
        };
        listeners.add(actual_listener);
        return () => void listeners.delete(actual_listener);
    };
    return subscribe;
}

/**
 * Convert a camel-case name into a dashed name
 * - for example
 *       dashify("BigManStyle")
 *        // "big-man-style"
 */
function dashify(camel) {
    return camel.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();
}

const register_to_dom = (elements) => {
    for (const [name, Element] of Object.entries(elements))
        customElements.define(dashify(name), Element);
};

class ObsidianView extends HTMLElement {
    constructor() {
        super(...arguments);
        this.onConnected = pub();
        this.onDisconnected = pub();
    }
    connectedCallback() {
        this.onConnected.publish();
    }
    disconnectedCallback() {
        this.onDisconnected.publish();
    }
}
ObsidianView.tag = "obsidian-view";
register_to_dom({ ObsidianView });

function parse_prefixes(...partstrings) {
    const prefixes = new Set();
    const parts = partstrings
        .map(part => part !== null && part !== void 0 ? part : "")
        .flatMap(parse_part);
    for (const part of parts)
        prefixes.add(part);
    return prefixes;
}
function query_attributes(container, attributes) {
    return Object.fromEntries(Object.entries(attributes).map(([key, attr]) => [
        key,
        Array.from(container.querySelectorAll(`[${attr}]`))
            .map(e => e.getAttribute(attr)),
    ]));
}
function parse_part(attr) {
    return attr
        .split(/\s+/)
        .map(s => s.trim())
        .filter(s => !!s);
}
function parse_exportparts(attr) {
    return attr
        .split(",")
        .map(s => s.trim())
        .filter(s => !!s)
        .map(s => s.includes(":")
        ? s.split(":").map(s => s.trim())[1]
        : s);
}
function stitch_exportparts_together(parts, gparts) {
    return ((prefix) => [...parts].flatMap(part => [
        `${part}:${prefix}-${part}`,
        ...(gparts.has(part) ? [part] : []),
    ]));
}

function auto_exportparts(container, root) {
    const prefixes = parse_prefixes(container.getAttribute("part"));
    const gprefixes = parse_prefixes(container.getAttribute("data-gpart"));
    const attrs = query_attributes(root, {
        part: "part",
        gpart: "data-gpart",
        exportparts: "exportparts",
        gexportparts: "gexportparts",
    });
    const parts = new Set([
        ...attrs.part.flatMap(parse_part),
        ...attrs.exportparts.flatMap(parse_exportparts),
    ]);
    const gparts = new Set([
        ...attrs.gpart.flatMap(parse_part),
        ...attrs.gexportparts.flatMap(parse_part),
    ]);
    if (parts.size)
        container.setAttribute("exportparts", [...prefixes]
            .flatMap(stitch_exportparts_together(parts, gparts))
            .join(", "));
    if (gparts.size || container.hasAttribute("data-gpart"))
        container.setAttribute("gexportparts", [
            ...gparts,
            ...[...gprefixes]
                .flatMap(prefix => [...parts].map(part => `${prefix}-${part}`)),
        ].join(" "));
}

function make_view_root({ name, css, onConnected, onDisconnected }) {
    const container = document.createElement(ObsidianView.tag);
    container.setAttribute("view", name);
    container.onConnected(onConnected);
    container.onDisconnected(onDisconnected);
    const shadow = container.attachShadow({ mode: "open" });
    apply_styles_to_shadow(shadow, css);
    let auto_exportparts_is_enabled = false;
    return {
        container,
        shadow,
        set auto_exportparts(enabled) {
            auto_exportparts_is_enabled = enabled;
        },
        render_into_shadow(content) {
            j(content, shadow);
            if (auto_exportparts_is_enabled)
                auto_exportparts(container, shadow);
            return container;
        },
    };
}

function apply_attributes(elements, attributes) {
    for (const [key, value] of Object.entries(attributes)) {
        if (typeof value === "string")
            elements.setAttribute(key, value);
        else if (typeof value === "number")
            elements.setAttribute(key, value.toString());
        else if (typeof value === "boolean") {
            if (value === true)
                elements.setAttribute(key, "");
            else
                elements.removeAttribute(key);
        }
        else if (typeof value === "undefined")
            elements.removeAttribute(key);
        else
            console.warn(`invalid attribute type ${key} is ${typeof value}`);
    }
}

function apply_details(element, freshMeta = {}, oldMeta = {}) {
    const { content, attrs: fresh = {} } = freshMeta;
    const { attrs: old = {} } = oldMeta;
    function actuate(freshvalue, oldvalue, name, value) {
        if (freshvalue !== oldvalue) {
            if (freshvalue === undefined)
                element.removeAttribute(name);
            else
                element.setAttribute(name, value());
        }
    }
    if (fresh)
        apply_attributes(element, fresh);
    actuate(fresh.class, old === null || old === void 0 ? void 0 : old.class, "class", () => fresh.class);
    actuate(fresh.part, old === null || old === void 0 ? void 0 : old.part, "part", () => fresh.part);
    actuate(fresh.gpart, old === null || old === void 0 ? void 0 : old.gpart, "data-gpart", () => fresh.gpart);
    if (content)
        j(content, element, { host: element });
}

const obsidian_custom_lit_directive = ((c) => ((props, meta = {}) => ({
    ['_$litDirective$']: c,
    values: [{ meta, props }],
})));

var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
const prepare_obsidian = ((shell) => (settings = {}, renderer) => {
    var _input, _first_connection, _root, _rerender, _use, _rend, _reactivity, _a;
    return (obsidian_custom_lit_directive((_a = class extends f {
            constructor() {
                var _b, _c;
                super(...arguments);
                _input.set(this, void 0);
                _first_connection.set(this, true);
                _root.set(this, make_view_root({
                    name: (_b = settings.name) !== null && _b !== void 0 ? _b : "",
                    css: [shell.context.theme, (_c = settings.styles) !== null && _c !== void 0 ? _c : i$3 ``],
                    onDisconnected: () => this.disconnected(),
                    onConnected: () => {
                        if (!__classPrivateFieldGet(this, _first_connection, "f"))
                            this.reconnected();
                        __classPrivateFieldSet(this, _first_connection, false, "f");
                    },
                }));
                _rerender.set(this, debounce(0, () => {
                    if (__classPrivateFieldGet(this, _input, "f"))
                        this.setValue(__classPrivateFieldGet(this, _root, "f").render_into_shadow(this.render(__classPrivateFieldGet(this, _input, "f"))));
                }));
                _use.set(this, new UseObsidian(__classPrivateFieldGet(this, _root, "f").container, __classPrivateFieldGet(this, _root, "f").shadow, __classPrivateFieldGet(this, _rerender, "f"), shell.context));
                _rend.set(this, UseObsidian.wrap(__classPrivateFieldGet(this, _use, "f"), renderer(__classPrivateFieldGet(this, _use, "f"))));
                _reactivity.set(this, setup_reactivity(__classPrivateFieldGet(this, _rend, "f"), __classPrivateFieldGet(this, _rerender, "f")));
            }
            update(_, props) {
                return __classPrivateFieldGet(this, _root, "f").render_into_shadow(this.render(...props));
            }
            render(input) {
                var _b, _c, _d, _e;
                apply_details(__classPrivateFieldGet(this, _root, "f").container, input.meta, (_b = __classPrivateFieldGet(this, _input, "f")) === null || _b === void 0 ? void 0 : _b.meta);
                __classPrivateFieldSet(this, _input, input, "f");
                __classPrivateFieldGet(this, _root, "f").auto_exportparts = ((_d = (_c = input.meta.auto_exportparts) !== null && _c !== void 0 ? _c : settings.auto_exportparts) !== null && _d !== void 0 ? _d : true);
                return (_e = __classPrivateFieldGet(this, _reactivity, "f")) === null || _e === void 0 ? void 0 : _e.render(...input.props);
            }
            reconnected() {
                UseObsidian.reconnect(__classPrivateFieldGet(this, _use, "f"));
                __classPrivateFieldSet(this, _reactivity, setup_reactivity(__classPrivateFieldGet(this, _rend, "f"), __classPrivateFieldGet(this, _rerender, "f")), "f");
            }
            disconnected() {
                UseObsidian.disconnect(__classPrivateFieldGet(this, _use, "f"));
                if (__classPrivateFieldGet(this, _reactivity, "f")) {
                    __classPrivateFieldGet(this, _reactivity, "f").stop();
                    __classPrivateFieldSet(this, _reactivity, undefined, "f");
                }
            }
        },
        _input = new WeakMap(),
        _first_connection = new WeakMap(),
        _root = new WeakMap(),
        _rerender = new WeakMap(),
        _use = new WeakMap(),
        _rend = new WeakMap(),
        _reactivity = new WeakMap(),
        _a)));
});

class Slate extends Shell {
    constructor(context) {
        super(context);
        this.light_component = prepare_oxygen(this);
        this.shadow_component = prepare_carbon(this);
        this.light_view = prepare_quartz(this);
        this.shadow_view = prepare_obsidian(this);
    }
    components(elements) {
        return apply.context(this.context)(elements);
    }
}

class Context {
    constructor() {
        this.theme = i$3 `
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}
	`;
    }
}

class DemoContext extends Context {
    constructor(theme) {
        super();
        this.theme = theme;
    }
}
const slate = new Slate();

const html = (strings, ...values) => (x(strings, ...values.map(value => ((value instanceof Signal)
    ? value.value
    : value))));

const styles$2 = i$3 `span { color: green }`;
let outerRenders = 0;
let innerRenders = 0;
const NestingOuter = slate.shadow_view({ styles: styles$2 }, use => (start) => {
    const rendercount = ++outerRenders;
    const count = use.signal(start);
    const increase = () => count.value += 1;
    return html `
		<span>${count} (renders ${rendercount})</span>
		<button @click=${increase}>outer</button>
		${NestingInner([1])}
	`;
});
const NestingInner = slate.shadow_view({ styles: styles$2 }, use => (start) => {
    const rendercount = ++innerRenders;
    const count = use.signal(start);
    const increase = () => count.value += 1;
    return html `
		<span>${count} (renders ${rendercount})</span>
		<button @click=${increase}>inner</button>
	`;
});

const QuartzTripler = slate.light_view(use => (start) => {
    // react hooks state
    const [alpha, setAlpha] = use.state(start);
    const increaseAlpha = () => setAlpha(alpha * 3);
    // flatstate
    const bravo = use.flatstate({ count: start });
    const increaseBravo = () => bravo.count *= 3;
    // preact signals
    const charlie = use.signal(start);
    const increaseCharlie = () => charlie.value *= 3;
    return html `
		<span>${alpha}</span>
		<button @click=${increaseAlpha}>quartz-a</button>

		<span>${bravo.count}</span>
		<button @click=${increaseBravo}>quartz-b</button>

		<span>${charlie}</span>
		<button @click=${increaseCharlie}>quartz-c</button>
	`;
});

const name = "quadrupler";
const styles$1 = i$3 `span { color: yellow }`;
const ObsidianQuadrupler = slate.shadow_view({ name, styles: styles$1 }, use => (start) => {
    const count = use.signal(start);
    const increase = () => count.value *= 4;
    return html `
		<span>${count}</span>
		<button @click=${increase}>obsidian</button>
	`;
});

class SlateSilver extends SilverElement {
    render() {
        return x `
			${QuartzTripler(1)}
			${ObsidianQuadrupler([33])}
			<br/>
			${NestingOuter([1])}
		`;
    }
}

const random = () => Math.ceil(Math.random() * 1000);
const styles = i$3 `button { color: green }`;
const SlateCarbon = slate.shadow_component({ styles }, use => {
    const x = use.signal(random);
    const randomize = () => x.value = random();
    return html `
		<span>${x}</span>
		<button @click=${randomize}>carbon</button>
	`;
});

const SlateOxygen = slate.light_component(use => {
    const count = use.signal(256);
    const decrease = () => count.value -= 8;
    return html `
		<span>${count}</span>
		<button @click=${decrease}>oxygen</button>
	`;
});

slate.context = new DemoContext(i$3 `
	button {
		font-weight: bold;
		color: red;
	}
`);
register_to_dom({
    SlateCarbon,
    SlateOxygen,
    ...slate.components({
        SlateGold,
        SlateSilver,
    }),
});
