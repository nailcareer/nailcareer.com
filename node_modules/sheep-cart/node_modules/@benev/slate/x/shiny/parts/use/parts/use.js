var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Use_context, _Use_rerender, _Use_counter, _Use_setups, _Use_setdowns, _Use_initStarts, _Use_initResults, _Use_initDowns, _Use_states, _Use_preparations, _Use_flatstates, _Use_signals, _Use_watches, _Counter_value;
import { maptool } from "../../../../tools/maptool.js";
import { flat, signals, watch } from "../../../state.js";
export class Use {
    static wrap(use, fun) {
        return ((...args) => {
            __classPrivateFieldGet(use, _Use_counter, "f").reset();
            return fun(...args);
        });
    }
    static disconnect(use) {
        // cleanup setups
        for (const down of __classPrivateFieldGet(use, _Use_setdowns, "f"))
            down();
        __classPrivateFieldGet(use, _Use_setdowns, "f").clear();
        // cleanup inits
        for (const down of __classPrivateFieldGet(use, _Use_initDowns, "f"))
            down();
        __classPrivateFieldGet(use, _Use_initDowns, "f").clear();
        __classPrivateFieldGet(use, _Use_initResults, "f").clear();
    }
    static reconnect(use) {
        // call all setups
        for (const up of __classPrivateFieldGet(use, _Use_setups, "f").values())
            __classPrivateFieldGet(use, _Use_setdowns, "f").add(up());
        // call all inits
        for (const [count, start] of __classPrivateFieldGet(use, _Use_initStarts, "f").entries()) {
            const [result, down] = start();
            __classPrivateFieldGet(use, _Use_initResults, "f").set(count, result);
            __classPrivateFieldGet(use, _Use_initDowns, "f").add(down);
        }
    }
    constructor(rerender, context) {
        _Use_context.set(this, void 0);
        _Use_rerender.set(this, void 0);
        _Use_counter.set(this, new Counter());
        _Use_setups.set(this, new Map());
        _Use_setdowns.set(this, new Set());
        _Use_initStarts.set(this, new Map());
        _Use_initResults.set(this, new Map());
        _Use_initDowns.set(this, new Set());
        _Use_states.set(this, new Map());
        _Use_preparations.set(this, new Map());
        _Use_flatstates.set(this, new Map());
        _Use_signals.set(this, new Map());
        _Use_watches.set(this, new Map());
        __classPrivateFieldSet(this, _Use_rerender, rerender, "f");
        __classPrivateFieldSet(this, _Use_context, context, "f");
    }
    get context() {
        return __classPrivateFieldGet(this, _Use_context, "f");
    }
    rerender() {
        __classPrivateFieldGet(this, _Use_rerender, "f").call(this);
    }
    setup(func) {
        const count = __classPrivateFieldGet(this, _Use_counter, "f").pull();
        if (!__classPrivateFieldGet(this, _Use_setups, "f").has(count)) {
            __classPrivateFieldGet(this, _Use_setups, "f").set(count, func);
            __classPrivateFieldGet(this, _Use_setdowns, "f").add(func());
        }
    }
    init(func) {
        const count = __classPrivateFieldGet(this, _Use_counter, "f").pull();
        if (!__classPrivateFieldGet(this, _Use_initStarts, "f").has(count)) {
            __classPrivateFieldGet(this, _Use_initStarts, "f").set(count, func);
            const [result, down] = func();
            __classPrivateFieldGet(this, _Use_initResults, "f").set(count, result);
            __classPrivateFieldGet(this, _Use_initDowns, "f").add(down);
            return result;
        }
        return __classPrivateFieldGet(this, _Use_initResults, "f").get(count);
    }
    prepare(prep) {
        const count = __classPrivateFieldGet(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet(this, _Use_preparations, "f")).grab(count, prep);
    }
    state(init) {
        const count = __classPrivateFieldGet(this, _Use_counter, "f").pull();
        const value = maptool(__classPrivateFieldGet(this, _Use_states, "f")).grab(count, () => ((typeof init === "function")
            ? init()
            : init));
        const setter = (v) => {
            __classPrivateFieldGet(this, _Use_states, "f").set(count, v);
            __classPrivateFieldGet(this, _Use_rerender, "f").call(this);
        };
        const getter = () => __classPrivateFieldGet(this, _Use_states, "f").get(count);
        return [value, setter, getter];
    }
    flatstate(init) {
        const count = __classPrivateFieldGet(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet(this, _Use_flatstates, "f")).grab(count, () => (flat.state((typeof init === "function")
            ? init()
            : init)));
    }
    signal(init) {
        const count = __classPrivateFieldGet(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet(this, _Use_signals, "f")).grab(count, () => (signals.signal((typeof init === "function")
            ? init()
            : init)));
    }
    computed(update) {
        const count = __classPrivateFieldGet(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet(this, _Use_signals, "f")).grab(count, () => (signals.computed(update)));
    }
    op() {
        const count = __classPrivateFieldGet(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet(this, _Use_signals, "f")).grab(count, () => signals.op());
    }
    watch(collector) {
        const count = __classPrivateFieldGet(this, _Use_counter, "f").pull();
        return maptool(__classPrivateFieldGet(this, _Use_watches, "f")).grab(count, () => watch.track(collector, data => {
            __classPrivateFieldGet(this, _Use_watches, "f").set(count, data);
            __classPrivateFieldGet(this, _Use_rerender, "f").call(this);
        }));
    }
}
_Use_context = new WeakMap(), _Use_rerender = new WeakMap(), _Use_counter = new WeakMap(), _Use_setups = new WeakMap(), _Use_setdowns = new WeakMap(), _Use_initStarts = new WeakMap(), _Use_initResults = new WeakMap(), _Use_initDowns = new WeakMap(), _Use_states = new WeakMap(), _Use_preparations = new WeakMap(), _Use_flatstates = new WeakMap(), _Use_signals = new WeakMap(), _Use_watches = new WeakMap();
class Counter {
    constructor() {
        _Counter_value.set(this, 0);
    }
    pull() {
        var _a, _b;
        return __classPrivateFieldSet(this, _Counter_value, (_b = __classPrivateFieldGet(this, _Counter_value, "f"), _a = _b++, _b), "f"), _a;
    }
    reset() {
        __classPrivateFieldSet(this, _Counter_value, 0, "f");
    }
}
_Counter_value = new WeakMap();
//# sourceMappingURL=use.js.map